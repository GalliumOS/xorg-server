From 4d62680bb8961651be15732cc815bf8cff2535ef Mon Sep 17 00:00:00 2001
From: Robert Ancell <robert.ancell@canonical.com>
Date: Fri, 29 Apr 2016 14:57:53 +0200
Subject: [PATCH xserver 1/3] XMir DDX

Contributions from:
  Maarten Lankhorst <maarten.lankhorst@ubuntu.com>
  Christopher James Halse Rogers <christopher.halse.rogers@canonical.com>
  Robert Ancell <robert.ancell@canonical.com>
  Andreas Pokorny <andreas.pokorny@canonical.com>
  Daniel van Vugt <daniel.van.vugt@canonical.com>
  Chris Townsend <christopher.townsend@canonical.com>
---
 configure.ac                |   25 
 hw/Makefile.am              |    9 
 hw/xmir/.gitignore          |    1 
 hw/xmir/Makefile.am         |   59 +
 hw/xmir/dri2/Makefile.am    |   14 
 hw/xmir/dri2/dri2.c         | 1398 +++++++++++++++++++++++++++++++++
 hw/xmir/dri2/dri2.h         |  364 ++++++++
 hw/xmir/dri2/dri2ext.c      |  683 ++++++++++++++++
 hw/xmir/dri2/dri2int.h      |   26 
 hw/xmir/xmir-cursor.c       |  225 +++++
 hw/xmir/xmir-cvt.c          |  304 +++++++
 hw/xmir/xmir-dri2.c         |  564 +++++++++++++
 hw/xmir/xmir-glamor.c       | 1180 ++++++++++++++++++++++++++++
 hw/xmir/xmir-input.c        |  650 +++++++++++++++
 hw/xmir/xmir-output.c       |  501 ++++++++++++
 hw/xmir/xmir-thread-proxy.c |  110 ++
 hw/xmir/xmir.c              | 1818 ++++++++++++++++++++++++++++++++++++++++++++
 hw/xmir/xmir.h              |  234 +++++
 18 files changed, 8163 insertions(+), 2 deletions(-)
 create mode 100644 hw/xmir/.gitignore
 create mode 100644 hw/xmir/Makefile.am
 create mode 100644 hw/xmir/dri2/Makefile.am
 create mode 100644 hw/xmir/dri2/dri2.c
 create mode 100644 hw/xmir/dri2/dri2.h
 create mode 100644 hw/xmir/dri2/dri2ext.c
 create mode 100644 hw/xmir/dri2/dri2int.h
 create mode 100644 hw/xmir/xmir-cursor.c
 create mode 100644 hw/xmir/xmir-cvt.c
 create mode 100644 hw/xmir/xmir-dri2.c
 create mode 100644 hw/xmir/xmir-glamor.c
 create mode 100644 hw/xmir/xmir-input.c
 create mode 100644 hw/xmir/xmir-output.c
 create mode 100644 hw/xmir/xmir-thread-proxy.c
 create mode 100644 hw/xmir/xmir.c
 create mode 100644 hw/xmir/xmir.h

--- a/configure.ac
+++ b/configure.ac
@@ -658,6 +658,7 @@ AC_ARG_ENABLE(xvfb,    	      AS_HELP_ST
 AC_ARG_ENABLE(xnest,   	      AS_HELP_STRING([--enable-xnest], [Build Xnest server (default: auto)]), [XNEST=$enableval], [XNEST=auto])
 AC_ARG_ENABLE(xquartz,        AS_HELP_STRING([--enable-xquartz], [Build Xquartz server for OS-X (default: auto)]), [XQUARTZ=$enableval], [XQUARTZ=auto])
 AC_ARG_ENABLE(xwayland,       AS_HELP_STRING([--enable-xwayland], [Build Xwayland server (default: auto)]), [XWAYLAND=$enableval], [XWAYLAND=auto])
+AC_ARG_ENABLE(xmir,           AS_HELP_STRING([--enable-xmir], [Build Xmir server (default: auto)]), [XMIR=$enableval], [XMIR=auto])
 AC_ARG_ENABLE(standalone-xpbproxy, AS_HELP_STRING([--enable-standalone-xpbproxy], [Build a standalone xpbproxy (in addition to the one integrated into Xquartz as a separate thread) (default: no)]), [STANDALONE_XPBPROXY=$enableval], [STANDALONE_XPBPROXY=no])
 AC_ARG_ENABLE(xwin,    	      AS_HELP_STRING([--enable-xwin], [Build XWin server (default: auto)]), [XWIN=$enableval], [XWIN=auto])
 AC_ARG_ENABLE(glamor,         AS_HELP_STRING([--enable-glamor], [Build glamor dix module (default: auto)]), [GLAMOR=$enableval], [GLAMOR=auto])
@@ -776,6 +777,7 @@ case $host_os in
 			XVFB=no
 			XNEST=no
 			XWAYLAND=no
+			XMIR=no
 
 			COMPOSITE=no
 			DGA=no
@@ -2557,6 +2559,27 @@ if test "x$XWAYLAND" = xyes; then
 	AC_SUBST(WAYLAND_PROTOCOLS_DATADIR, `$PKG_CONFIG --variable=pkgdatadir wayland-protocols`)
 fi
 
+dnl Xmir DDX
+
+PKG_CHECK_MODULES(XMIRMODULES, [mirclient >= 0.13.1 mir-client-platform-mesa libdrm epoxy], [have_xmir=yes], [have_xmir=no])
+AC_MSG_CHECKING([whether to build Xmir DDX])
+if test "x$XMIR" = xauto; then
+   XMIR="$have_xmir"
+fi
+AC_MSG_RESULT([$XMIR])
+AM_CONDITIONAL(XMIR, [test "x$XMIR" = xyes])
+
+if test "x$XMIR" = xyes; then
+	if test "x$have_xmir" = xno; then
+		AC_MSG_ERROR([Xmir build explicitly requested, but required modules not found.])
+	fi
+
+	XMIR_LIBS="$FB_LIB $FIXES_LIB $MI_LIB $XEXT_LIB $DBE_LIB $RECORD_LIB $GLX_LIBS $RANDR_LIB $RENDER_LIB $DAMAGE_LIB $DRI3_LIB $PRESENT_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $MIEXT_SHADOW_LIB $XI_LIB $XKB_LIB $XKB_STUB_LIB $COMPOSITE_LIB $MAIN_LIB $DIX_LIB $OS_LIB"
+	XMIR_SYS_LIBS="$XMIRMODULES_LIBS $GLX_SYS_LIBS"
+	AC_SUBST([XMIR_LIBS])
+	AC_SUBST([XMIR_SYS_LIBS])
+fi
+
 
 dnl and the rest of these are generic, so they're in config.h
 dnl 
@@ -2706,6 +2729,8 @@ hw/kdrive/fbdev/Makefile
 hw/kdrive/linux/Makefile
 hw/kdrive/src/Makefile
 hw/xwayland/Makefile
+hw/xmir/Makefile
+hw/xmir/dri2/Makefile
 test/Makefile
 test/xi1/Makefile
 test/xi2/Makefile
--- a/hw/Makefile.am
+++ b/hw/Makefile.am
@@ -30,6 +30,10 @@ if XWAYLAND
 XWAYLAND_SUBDIRS = xwayland
 endif
 
+if XMIR
+XMIR_SUBDIRS = xmir
+endif
+
 SUBDIRS =			\
 	$(XORG_SUBDIRS)		\
 	$(XWIN_SUBDIRS)		\
@@ -38,9 +42,10 @@ SUBDIRS =			\
 	$(DMX_SUBDIRS)		\
 	$(KDRIVE_SUBDIRS)	\
 	$(XQUARTZ_SUBDIRS)	\
-	$(XWAYLAND_SUBDIRS)
+	$(XWAYLAND_SUBDIRS) \
+	$(XMIR_SUBDIRS)
 
-DIST_SUBDIRS = dmx xfree86 vfb xnest xwin xquartz kdrive xwayland
+DIST_SUBDIRS = dmx xfree86 vfb xnest xwin xquartz kdrive xwayland xmir
 
 relink:
 	$(AM_V_at)for i in $(SUBDIRS) ; do $(MAKE) -C $$i relink || exit 1 ; done
--- /dev/null
+++ b/hw/xmir/.gitignore
@@ -0,0 +1 @@
+Xmir
--- /dev/null
+++ b/hw/xmir/Makefile.am
@@ -0,0 +1,59 @@
+bin_PROGRAMS = Xmir
+
+if DRI2
+SUBDIRS = dri2
+endif
+
+Xmir_CFLAGS =				\
+	-I$(top_srcdir)/glamor		\
+	-I$(srcdir)/dri2		\
+	-I$(top_srcdir)/glx		\
+	-I$(top_srcdir)/hw/xfree86/common		\
+	-DHAVE_DIX_CONFIG_H		\
+	$(XMIRMODULES_CFLAGS)			\
+	$(DIX_CFLAGS)			\
+	$(GLAMOR_CFLAGS)		\
+	$(GBM_CFLAGS)
+
+Xmir_SOURCES =				\
+	xmir.c				\
+	xmir-cursor.c			\
+	xmir-input.c			\
+	xmir-output.c			\
+	xmir-cvt.c			\
+	xmir-thread-proxy.c		\
+	xmir.h				\
+	$(top_srcdir)/Xi/stubs.c	\
+	$(top_srcdir)/mi/miinitext.c
+
+Xmir_LDADD =				\
+	$(glamor_lib)			\
+	$(glxdri_lib)			\
+	$(XMIR_LIBS)			\
+	$(XMIR_SYS_LIBS)		\
+	$(XSERVER_SYS_LIBS)
+Xmir_LDFLAGS = $(LD_EXPORT_SYMBOLS_FLAG)
+
+if GLAMOR_EGL
+Xmir_SOURCES += xmir-glamor.c
+
+glamor_lib = $(top_builddir)/glamor/libglamor.la
+
+if DRI2
+Xmir_SOURCES += xmir-dri2.c
+endif
+
+Xmir_LDADD += $(GLAMOR_LIBS) $(GBM_LIBS) -lEGL -lGL
+endif
+
+if DRI2
+Xmir_LDADD += dri2/libdri2.la
+endif
+
+glxdri_lib = $(top_builddir)/glx/libglxdri.la
+if NO_UNDEFINED
+glxdri_lib += $(LIBDRM_LIBS) $(PIXMAN_LIBS)
+endif
+
+relink:
+	$(AM_V_at)rm -f Xmir$(EXEEXT) && $(MAKE) Xmir$(EXEEXT)
--- /dev/null
+++ b/hw/xmir/dri2/Makefile.am
@@ -0,0 +1,14 @@
+noinst_LTLIBRARIES = libdri2.la
+
+AM_CFLAGS = \
+	-DHAVE_DIX_CONFIG_H	\
+	-I$(top_srcdir)/hw/xmir	\
+	$(DIX_CFLAGS)		\
+	$(XMIRMODULES_CFLAGS)
+
+libdri2_la_SOURCES = \
+	dri2.c \
+	dri2.h \
+	dri2ext.c \
+	dri2int.h
+
--- /dev/null
+++ b/hw/xmir/dri2/dri2.c
@@ -0,0 +1,1398 @@
+/*
+ * Copyright © 2007, 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Kristian Høgsberg (krh@redhat.com)
+ */
+
+#include <dix-config.h>
+
+#include <errno.h>
+#include "list.h"
+#include "scrnintstr.h"
+#include "windowstr.h"
+#include "dixstruct.h"
+#include "dri2.h"
+#include "dri2int.h"
+#include "damage.h"
+
+CARD8 dri2_major;               /* version of DRI2 supported by DDX */
+CARD8 dri2_minor;
+
+static DevPrivateKeyRec dri2ScreenPrivateKeyRec;
+
+#define dri2ScreenPrivateKey (&dri2ScreenPrivateKeyRec)
+
+static DevPrivateKeyRec dri2WindowPrivateKeyRec;
+
+#define dri2WindowPrivateKey (&dri2WindowPrivateKeyRec)
+
+static DevPrivateKeyRec dri2PixmapPrivateKeyRec;
+
+#define dri2PixmapPrivateKey (&dri2PixmapPrivateKeyRec)
+
+static RESTYPE dri2DrawableRes;
+
+typedef struct _DRI2Screen *DRI2ScreenPtr;
+
+typedef struct _DRI2Drawable {
+    DRI2ScreenPtr dri2_screen;
+    DrawablePtr drawable;
+    struct xorg_list reference_list;
+    int width;
+    int height;
+    DRI2BufferPtr *buffers;
+    int bufferCount;
+    unsigned int swapsPending;
+    ClientPtr blockedClient;
+    Bool blockedOnMsc;
+    int swap_interval;
+    CARD64 swap_count;
+    int64_t target_sbc;         /* -1 means no SBC wait outstanding */
+    CARD64 last_swap_target;    /* most recently queued swap target */
+    CARD64 last_swap_msc;       /* msc at completion of most recent swap */
+    CARD64 last_swap_ust;       /* ust at completion of most recent swap */
+    int swap_limit;             /* for N-buffering */
+    Bool needInvalidate;
+} DRI2DrawableRec, *DRI2DrawablePtr;
+
+typedef struct _DRI2Screen {
+    ScreenPtr screen;
+    int refcnt;
+    unsigned int numDrivers;
+    const char **driverNames;
+    const char *deviceName;
+    int fd;
+    unsigned int lastSequence;
+
+    DRI2CreateBufferProcPtr CreateBuffer;
+    DRI2DestroyBufferProcPtr DestroyBuffer;
+    DRI2CopyRegionProcPtr CopyRegion;
+    DRI2ScheduleSwapProcPtr ScheduleSwap;
+    DRI2GetMSCProcPtr GetMSC;
+    DRI2ScheduleWaitMSCProcPtr ScheduleWaitMSC;
+    DRI2AuthMagic2ProcPtr AuthMagic;
+    DRI2AuthMagicProcPtr LegacyAuthMagic;
+    DRI2ReuseBufferNotifyProcPtr ReuseBufferNotify;
+    DRI2SwapLimitValidateProcPtr SwapLimitValidate;
+    DRI2GetParamProcPtr GetParam;
+
+    ConfigNotifyProcPtr ConfigNotify;
+    SetWindowPixmapProcPtr SetWindowPixmap;
+    DRI2CreateBuffer2ProcPtr CreateBuffer2;
+    DRI2DestroyBuffer2ProcPtr DestroyBuffer2;
+    DRI2CopyRegion2ProcPtr CopyRegion2;
+} DRI2ScreenRec;
+
+static void
+destroy_buffer(DrawablePtr pDraw, DRI2BufferPtr buffer);
+
+static DRI2ScreenPtr
+DRI2GetScreen(ScreenPtr pScreen)
+{
+    return dixLookupPrivate(&pScreen->devPrivates, dri2ScreenPrivateKey);
+}
+
+static DRI2DrawablePtr
+DRI2GetDrawable(DrawablePtr pDraw)
+{
+    WindowPtr pWin;
+    PixmapPtr pPixmap;
+
+    switch (pDraw->type) {
+    case DRAWABLE_WINDOW:
+        pWin = (WindowPtr) pDraw;
+        return dixLookupPrivate(&pWin->devPrivates, dri2WindowPrivateKey);
+    case DRAWABLE_PIXMAP:
+        pPixmap = (PixmapPtr) pDraw;
+        return dixLookupPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey);
+    default:
+        return NULL;
+    }
+}
+
+static DRI2DrawablePtr
+DRI2AllocateDrawable(DrawablePtr pDraw)
+{
+    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
+    DRI2DrawablePtr pPriv;
+    CARD64 ust;
+    WindowPtr pWin;
+    PixmapPtr pPixmap;
+
+    pPriv = malloc(sizeof *pPriv);
+    if (pPriv == NULL)
+        return NULL;
+
+    pPriv->dri2_screen = ds;
+    pPriv->drawable = pDraw;
+    pPriv->width = pDraw->width;
+    pPriv->height = pDraw->height;
+    pPriv->buffers = NULL;
+    pPriv->bufferCount = 0;
+    pPriv->swapsPending = 0;
+    pPriv->blockedClient = NULL;
+    pPriv->blockedOnMsc = FALSE;
+    pPriv->swap_count = 0;
+    pPriv->target_sbc = -1;
+    pPriv->swap_interval = 1;
+    /* Initialize last swap target from DDX if possible */
+    if (!ds->GetMSC || !(*ds->GetMSC) (pDraw, &ust, &pPriv->last_swap_target))
+        pPriv->last_swap_target = 0;
+
+    pPriv->swap_limit = 1;      /* default to double buffering */
+    pPriv->last_swap_msc = 0;
+    pPriv->last_swap_ust = 0;
+    xorg_list_init(&pPriv->reference_list);
+    pPriv->needInvalidate = FALSE;
+    if (pDraw->type == DRAWABLE_WINDOW) {
+        pWin = (WindowPtr) pDraw;
+        dixSetPrivate(&pWin->devPrivates, dri2WindowPrivateKey, pPriv);
+    }
+    else {
+        pPixmap = (PixmapPtr) pDraw;
+        dixSetPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey, pPriv);
+    }
+
+    return pPriv;
+}
+
+Bool
+DRI2SwapLimit(DrawablePtr pDraw, int swap_limit)
+{
+    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDraw);
+    DRI2ScreenPtr ds;
+
+    if (!pPriv)
+        return FALSE;
+
+    ds = pPriv->dri2_screen;
+
+    if (!ds->SwapLimitValidate || !ds->SwapLimitValidate(pDraw, swap_limit))
+        return FALSE;
+
+    pPriv->swap_limit = swap_limit;
+
+    /* Check throttling */
+    if (pPriv->swapsPending >= pPriv->swap_limit)
+        return TRUE;
+
+    if (pPriv->target_sbc == -1 && !pPriv->blockedOnMsc) {
+        if (pPriv->blockedClient) {
+            AttendClient(pPriv->blockedClient);
+            pPriv->blockedClient = NULL;
+        }
+    }
+
+    return TRUE;
+}
+
+typedef struct DRI2DrawableRefRec {
+    XID id;
+    XID dri2_id;
+    DRI2InvalidateProcPtr invalidate;
+    void *priv;
+    struct xorg_list link;
+} DRI2DrawableRefRec, *DRI2DrawableRefPtr;
+
+static DRI2DrawableRefPtr
+DRI2LookupDrawableRef(DRI2DrawablePtr pPriv, XID id)
+{
+    DRI2DrawableRefPtr ref;
+
+    xorg_list_for_each_entry(ref, &pPriv->reference_list, link) {
+        if (ref->id == id)
+            return ref;
+    }
+
+    return NULL;
+}
+
+static int
+DRI2AddDrawableRef(DRI2DrawablePtr pPriv, XID id, XID dri2_id,
+                   DRI2InvalidateProcPtr invalidate, void *priv)
+{
+    DRI2DrawableRefPtr ref;
+
+    ref = malloc(sizeof *ref);
+    if (ref == NULL)
+        return BadAlloc;
+
+    if (!AddResource(dri2_id, dri2DrawableRes, pPriv)) {
+        free(ref);
+        return BadAlloc;
+    }
+    if (!DRI2LookupDrawableRef(pPriv, id))
+        if (!AddResource(id, dri2DrawableRes, pPriv)) {
+            FreeResourceByType(dri2_id, dri2DrawableRes, TRUE);
+            free(ref);
+            return BadAlloc;
+        }
+
+    ref->id = id;
+    ref->dri2_id = dri2_id;
+    ref->invalidate = invalidate;
+    ref->priv = priv;
+    xorg_list_add(&ref->link, &pPriv->reference_list);
+
+    return Success;
+}
+
+int
+DRI2CreateDrawable2(ClientPtr client, DrawablePtr pDraw, XID id,
+                    DRI2InvalidateProcPtr invalidate, void *priv,
+                    XID *dri2_id_out)
+{
+    DRI2DrawablePtr pPriv;
+    XID dri2_id;
+    int rc;
+
+    pPriv = DRI2GetDrawable(pDraw);
+    if (pPriv == NULL)
+        pPriv = DRI2AllocateDrawable(pDraw);
+    if (pPriv == NULL)
+        return BadAlloc;
+
+    dri2_id = FakeClientID(client->index);
+    rc = DRI2AddDrawableRef(pPriv, id, dri2_id, invalidate, priv);
+    if (rc != Success)
+        return rc;
+
+    if (dri2_id_out)
+        *dri2_id_out = dri2_id;
+
+    return Success;
+}
+
+int
+DRI2CreateDrawable(ClientPtr client, DrawablePtr pDraw, XID id,
+                   DRI2InvalidateProcPtr invalidate, void *priv)
+{
+    return DRI2CreateDrawable2(client, pDraw, id, invalidate, priv, NULL);
+}
+
+static int
+DRI2DrawableGone(void *p, XID id)
+{
+    DRI2DrawablePtr pPriv = p;
+    DRI2DrawableRefPtr ref, next;
+    WindowPtr pWin;
+    PixmapPtr pPixmap;
+    DrawablePtr pDraw;
+    int i;
+
+    xorg_list_for_each_entry_safe(ref, next, &pPriv->reference_list, link) {
+        if (ref->dri2_id == id) {
+            xorg_list_del(&ref->link);
+            /* If this was the last ref under this X drawable XID,
+             * unregister the X drawable resource. */
+            if (!DRI2LookupDrawableRef(pPriv, ref->id))
+                FreeResourceByType(ref->id, dri2DrawableRes, TRUE);
+            free(ref);
+            break;
+        }
+
+        if (ref->id == id) {
+            xorg_list_del(&ref->link);
+            FreeResourceByType(ref->dri2_id, dri2DrawableRes, TRUE);
+            free(ref);
+        }
+    }
+
+    if (!xorg_list_is_empty(&pPriv->reference_list))
+        return Success;
+
+    pDraw = pPriv->drawable;
+    if (pDraw->type == DRAWABLE_WINDOW) {
+        pWin = (WindowPtr) pDraw;
+        dixSetPrivate(&pWin->devPrivates, dri2WindowPrivateKey, NULL);
+    }
+    else {
+        pPixmap = (PixmapPtr) pDraw;
+        dixSetPrivate(&pPixmap->devPrivates, dri2PixmapPrivateKey, NULL);
+    }
+
+    if (pPriv->buffers != NULL) {
+        for (i = 0; i < pPriv->bufferCount; i++)
+            destroy_buffer(pDraw, pPriv->buffers[i]);
+
+        free(pPriv->buffers);
+    }
+
+    free(pPriv);
+
+    return Success;
+}
+
+static DRI2BufferPtr
+create_buffer(DRI2ScreenPtr ds, DrawablePtr pDraw,
+              unsigned int attachment, unsigned int format)
+{
+    DRI2BufferPtr buffer;
+    if (ds->CreateBuffer2)
+        buffer = (*ds->CreateBuffer2)(pDraw->pScreen, pDraw, attachment, format);
+    else
+        buffer = (*ds->CreateBuffer)(pDraw, attachment, format);
+    return buffer;
+}
+
+static void
+destroy_buffer(DrawablePtr pDraw, DRI2BufferPtr buffer)
+{
+    ScreenPtr pScreen = pDraw->pScreen;
+    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
+    if (ds->DestroyBuffer2)
+        (*ds->DestroyBuffer2)(pScreen, pDraw, buffer);
+    else
+        (*ds->DestroyBuffer)(pDraw, buffer);
+}
+
+static int
+find_attachment(DRI2DrawablePtr pPriv, unsigned attachment)
+{
+    int i;
+
+    if (pPriv->buffers == NULL) {
+        return -1;
+    }
+
+    for (i = 0; i < pPriv->bufferCount; i++) {
+        if ((pPriv->buffers[i] != NULL)
+            && (pPriv->buffers[i]->attachment == attachment)) {
+            return i;
+        }
+    }
+
+    return -1;
+}
+
+static Bool
+allocate_or_reuse_buffer(DrawablePtr pDraw, DRI2ScreenPtr ds,
+                         DRI2DrawablePtr pPriv,
+                         unsigned int attachment, unsigned int format,
+                         int dimensions_match, DRI2BufferPtr * buffer)
+{
+    int old_buf = find_attachment(pPriv, attachment);
+
+    if ((old_buf < 0)
+        || attachment == DRI2BufferFrontLeft
+        || !dimensions_match || (pPriv->buffers[old_buf]->format != format)) {
+        *buffer = create_buffer(ds, pDraw, attachment, format);
+        return TRUE;
+
+    }
+    else {
+        *buffer = pPriv->buffers[old_buf];
+
+        if (ds->ReuseBufferNotify)
+            (*ds->ReuseBufferNotify) (pDraw, *buffer);
+
+        pPriv->buffers[old_buf] = NULL;
+        return FALSE;
+    }
+}
+
+static void
+update_dri2_drawable_buffers(DRI2DrawablePtr pPriv, DrawablePtr pDraw,
+                             DRI2BufferPtr * buffers, int out_count, int *width,
+                             int *height)
+{
+    int i;
+
+    if (pPriv->buffers != NULL) {
+        for (i = 0; i < pPriv->bufferCount; i++) {
+            if (pPriv->buffers[i] != NULL) {
+                destroy_buffer(pDraw, pPriv->buffers[i]);
+            }
+        }
+
+        free(pPriv->buffers);
+    }
+
+    pPriv->buffers = buffers;
+    pPriv->bufferCount = out_count;
+    pPriv->width = pDraw->width;
+    pPriv->height = pDraw->height;
+    *width = pPriv->width;
+    *height = pPriv->height;
+}
+
+static DRI2BufferPtr *
+do_get_buffers(DrawablePtr pDraw, int *width, int *height,
+               unsigned int *attachments, int count, int *out_count,
+               int has_format)
+{
+    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDraw);
+    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
+    DRI2BufferPtr *buffers;
+    int need_real_front = 0;
+    int need_fake_front = 0;
+    int have_fake_front = 0;
+    int front_format = 0;
+    int dimensions_match;
+    int buffers_changed = 0;
+    int i;
+
+    if (!pPriv) {
+        *width = pDraw->width;
+        *height = pDraw->height;
+        *out_count = 0;
+        return NULL;
+    }
+
+    dimensions_match = (pDraw->width == pPriv->width)
+        && (pDraw->height == pPriv->height);
+
+    buffers = calloc((count + 1), sizeof(buffers[0]));
+    if (!buffers)
+        goto err_out;
+
+    for (i = 0; i < count; i++) {
+        const unsigned attachment = *(attachments++);
+        const unsigned format = (has_format) ? *(attachments++) : 0;
+
+        if (allocate_or_reuse_buffer(pDraw, ds, pPriv, attachment,
+                                     format, dimensions_match, &buffers[i]))
+            buffers_changed = 1;
+
+        if (buffers[i] == NULL)
+            goto err_out;
+
+        /* If the drawable is a window and the front-buffer is requested,
+         * silently add the fake front-buffer to the list of requested
+         * attachments.  The counting logic in the loop accounts for the case
+         * where the client requests both the fake and real front-buffer.
+         */
+        if (attachment == DRI2BufferBackLeft) {
+            need_real_front++;
+            front_format = format;
+        }
+
+        if (attachment == DRI2BufferFrontLeft) {
+            need_real_front--;
+            front_format = format;
+
+            if (pDraw->type == DRAWABLE_WINDOW) {
+                need_fake_front++;
+            }
+        }
+
+        if (pDraw->type == DRAWABLE_WINDOW) {
+            if (attachment == DRI2BufferFakeFrontLeft) {
+                need_fake_front--;
+                have_fake_front = 1;
+            }
+        }
+    }
+
+    if (need_real_front > 0) {
+        if (allocate_or_reuse_buffer(pDraw, ds, pPriv, DRI2BufferFrontLeft,
+                                     front_format, dimensions_match,
+                                     &buffers[i]))
+            buffers_changed = 1;
+
+        if (buffers[i] == NULL)
+            goto err_out;
+        i++;
+    }
+
+    if (need_fake_front > 0) {
+        if (allocate_or_reuse_buffer(pDraw, ds, pPriv, DRI2BufferFakeFrontLeft,
+                                     front_format, dimensions_match,
+                                     &buffers[i]))
+            buffers_changed = 1;
+
+        if (buffers[i] == NULL)
+            goto err_out;
+
+        i++;
+        have_fake_front = 1;
+    }
+
+    *out_count = i;
+
+    update_dri2_drawable_buffers(pPriv, pDraw, buffers, *out_count, width,
+                                 height);
+
+    /* If the client is getting a fake front-buffer, pre-fill it with the
+     * contents of the real front-buffer.  This ensures correct operation of
+     * applications that call glXWaitX before calling glDrawBuffer.
+     */
+    if (have_fake_front && buffers_changed) {
+        BoxRec box;
+        RegionRec region;
+
+        box.x1 = 0;
+        box.y1 = 0;
+        box.x2 = pPriv->width;
+        box.y2 = pPriv->height;
+        RegionInit(&region, &box, 0);
+
+        DRI2CopyRegion(pDraw, &region, DRI2BufferFakeFrontLeft,
+                       DRI2BufferFrontLeft);
+    }
+
+    pPriv->needInvalidate = TRUE;
+
+    return pPriv->buffers;
+
+ err_out:
+
+    *out_count = 0;
+
+    if (buffers) {
+        for (i = 0; i < count; i++) {
+            if (buffers[i] != NULL)
+                destroy_buffer(pDraw, buffers[i]);
+        }
+
+        free(buffers);
+        buffers = NULL;
+    }
+
+    update_dri2_drawable_buffers(pPriv, pDraw, buffers, *out_count, width,
+                                 height);
+
+    return buffers;
+}
+
+DRI2BufferPtr *
+DRI2GetBuffers(DrawablePtr pDraw, int *width, int *height,
+               unsigned int *attachments, int count, int *out_count)
+{
+    return do_get_buffers(pDraw, width, height, attachments, count,
+                          out_count, FALSE);
+}
+
+DRI2BufferPtr *
+DRI2GetBuffersWithFormat(DrawablePtr pDraw, int *width, int *height,
+                         unsigned int *attachments, int count, int *out_count)
+{
+    return do_get_buffers(pDraw, width, height, attachments, count,
+                          out_count, TRUE);
+}
+
+static void
+DRI2InvalidateDrawable(DrawablePtr pDraw)
+{
+    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDraw);
+    DRI2DrawableRefPtr ref;
+
+    if (!pPriv || !pPriv->needInvalidate)
+        return;
+
+    pPriv->needInvalidate = FALSE;
+
+    xorg_list_for_each_entry(ref, &pPriv->reference_list, link)
+        ref->invalidate(pDraw, ref->priv, ref->id);
+}
+
+/*
+ * In the direct rendered case, we throttle the clients that have more
+ * than their share of outstanding swaps (and thus busy buffers) when a
+ * new GetBuffers request is received.  In the AIGLX case, we allow the
+ * client to get the new buffers, but throttle when the next GLX request
+ * comes in (see __glXDRIcontextWait()).
+ */
+Bool
+DRI2ThrottleClient(ClientPtr client, DrawablePtr pDraw)
+{
+    DRI2DrawablePtr pPriv;
+
+    pPriv = DRI2GetDrawable(pDraw);
+    if (pPriv == NULL)
+        return FALSE;
+
+    /* Throttle to swap limit */
+    if ((pPriv->swapsPending >= pPriv->swap_limit) && !pPriv->blockedClient) {
+        ResetCurrentRequest(client);
+        client->sequence--;
+        IgnoreClient(client);
+        pPriv->blockedClient = client;
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static void
+__DRI2BlockClient(ClientPtr client, DRI2DrawablePtr pPriv)
+{
+    if (pPriv->blockedClient == NULL) {
+        IgnoreClient(client);
+        pPriv->blockedClient = client;
+    }
+}
+
+void
+DRI2BlockClient(ClientPtr client, DrawablePtr pDraw)
+{
+    DRI2DrawablePtr pPriv;
+
+    pPriv = DRI2GetDrawable(pDraw);
+    if (pPriv == NULL)
+        return;
+
+    __DRI2BlockClient(client, pPriv);
+    pPriv->blockedOnMsc = TRUE;
+}
+
+static inline PixmapPtr GetDrawablePixmap(DrawablePtr drawable)
+{
+    if (drawable->type == DRAWABLE_PIXMAP)
+        return (PixmapPtr)drawable;
+    else {
+        struct _Window *pWin = (struct _Window *)drawable;
+        return drawable->pScreen->GetWindowPixmap(pWin);
+    }
+}
+
+/*
+ * A TraverseTree callback to invalidate all windows using the same
+ * pixmap
+ */
+static int
+DRI2InvalidateWalk(WindowPtr pWin, void *data)
+{
+    if (pWin->drawable.pScreen->GetWindowPixmap(pWin) != data)
+        return WT_DONTWALKCHILDREN;
+    DRI2InvalidateDrawable(&pWin->drawable);
+    return WT_WALKCHILDREN;
+}
+
+static void
+DRI2InvalidateDrawableAll(DrawablePtr pDraw)
+{
+    if (pDraw->type == DRAWABLE_WINDOW) {
+        WindowPtr pWin = (WindowPtr) pDraw;
+        PixmapPtr pPixmap = pDraw->pScreen->GetWindowPixmap(pWin);
+
+        /*
+         * Find the top-most window using this pixmap
+         */
+        while (pWin->parent &&
+               pDraw->pScreen->GetWindowPixmap(pWin->parent) == pPixmap)
+            pWin = pWin->parent;
+
+        /*
+         * Walk the sub-tree to invalidate all of the
+         * windows using the same pixmap
+         */
+        TraverseTree(pWin, DRI2InvalidateWalk, pPixmap);
+        DRI2InvalidateDrawable(&pPixmap->drawable);
+    }
+    else
+        DRI2InvalidateDrawable(pDraw);
+}
+
+static void dri2_copy_region(DrawablePtr pDraw, RegionPtr pRegion,
+                             DRI2BufferPtr pDest, DRI2BufferPtr pSrc)
+{
+    ScreenPtr pScreen = pDraw->pScreen;
+    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
+
+    if (ds->CopyRegion2)
+        (*ds->CopyRegion2)(pScreen, pDraw, pRegion, pDest, pSrc);
+    else
+        (*ds->CopyRegion) (pDraw, pRegion, pDest, pSrc);
+}
+
+int
+DRI2CopyRegion(DrawablePtr pDraw, RegionPtr pRegion,
+               unsigned int dest, unsigned int src)
+{
+    DRI2DrawablePtr pPriv;
+    DRI2BufferPtr pDestBuffer, pSrcBuffer;
+    int i;
+
+    pPriv = DRI2GetDrawable(pDraw);
+    if (pPriv == NULL)
+        return BadDrawable;
+
+    pDestBuffer = NULL;
+    pSrcBuffer = NULL;
+    for (i = 0; i < pPriv->bufferCount; i++) {
+        if (pPriv->buffers[i]->attachment == dest)
+            pDestBuffer = (DRI2BufferPtr) pPriv->buffers[i];
+        if (pPriv->buffers[i]->attachment == src)
+            pSrcBuffer = (DRI2BufferPtr) pPriv->buffers[i];
+    }
+    if (pSrcBuffer == NULL || pDestBuffer == NULL)
+        return BadValue;
+
+    dri2_copy_region(pDraw, pRegion, pDestBuffer, pSrcBuffer);
+
+    return Success;
+}
+
+/* Can this drawable be page flipped? */
+Bool
+DRI2CanFlip(DrawablePtr pDraw)
+{
+    ScreenPtr pScreen = pDraw->pScreen;
+    WindowPtr pWin, pRoot;
+    PixmapPtr pWinPixmap, pRootPixmap;
+
+    if (pDraw->type == DRAWABLE_PIXMAP)
+        return TRUE;
+
+    pRoot = pScreen->root;
+    pRootPixmap = pScreen->GetWindowPixmap(pRoot);
+
+    pWin = (WindowPtr) pDraw;
+    pWinPixmap = pScreen->GetWindowPixmap(pWin);
+    if (pRootPixmap != pWinPixmap)
+        return FALSE;
+    if (!RegionEqual(&pWin->clipList, &pRoot->winSize))
+        return FALSE;
+
+    /* Does the window match the pixmap exactly? */
+    if (pDraw->x != 0 || pDraw->y != 0 ||
+#ifdef COMPOSITE
+        pDraw->x != pWinPixmap->screen_x || pDraw->y != pWinPixmap->screen_y ||
+#endif
+        pDraw->width != pWinPixmap->drawable.width ||
+        pDraw->height != pWinPixmap->drawable.height)
+        return FALSE;
+
+    return TRUE;
+}
+
+/* Can we do a pixmap exchange instead of a blit? */
+Bool
+DRI2CanExchange(DrawablePtr pDraw)
+{
+    return FALSE;
+}
+
+void
+DRI2WaitMSCComplete(ClientPtr client, DrawablePtr pDraw, int frame,
+                    unsigned int tv_sec, unsigned int tv_usec)
+{
+    DRI2DrawablePtr pPriv;
+
+    pPriv = DRI2GetDrawable(pDraw);
+    if (pPriv == NULL)
+        return;
+
+    ProcDRI2WaitMSCReply(client, ((CARD64) tv_sec * 1000000) + tv_usec,
+                         frame, pPriv->swap_count);
+
+    if (pPriv->blockedClient)
+        AttendClient(pPriv->blockedClient);
+
+    pPriv->blockedClient = NULL;
+    pPriv->blockedOnMsc = FALSE;
+}
+
+static void
+DRI2WakeClient(ClientPtr client, DrawablePtr pDraw, int frame,
+               unsigned int tv_sec, unsigned int tv_usec)
+{
+    DRI2DrawablePtr pPriv;
+
+    pPriv = DRI2GetDrawable(pDraw);
+    if (pPriv == NULL) {
+        ErrorF("[DRI2] %s: bad drawable\n", __func__);
+        return;
+    }
+
+    /*
+     * Swap completed.
+     * Wake the client iff:
+     *   - it was waiting on SBC
+     *   - was blocked due to GLX make current
+     *   - was blocked due to swap throttling
+     *   - is not blocked due to an MSC wait
+     */
+    if (pPriv->target_sbc != -1 && pPriv->target_sbc <= pPriv->swap_count) {
+        ProcDRI2WaitMSCReply(client, ((CARD64) tv_sec * 1000000) + tv_usec,
+                             frame, pPriv->swap_count);
+        pPriv->target_sbc = -1;
+
+        AttendClient(pPriv->blockedClient);
+        pPriv->blockedClient = NULL;
+    }
+    else if (pPriv->target_sbc == -1 && !pPriv->blockedOnMsc) {
+        if (pPriv->blockedClient) {
+            AttendClient(pPriv->blockedClient);
+            pPriv->blockedClient = NULL;
+        }
+    }
+}
+
+void
+DRI2SwapComplete(ClientPtr client, DrawablePtr pDraw, int frame,
+                 unsigned int tv_sec, unsigned int tv_usec, int type,
+                 DRI2SwapEventPtr swap_complete, void *swap_data)
+{
+    DRI2DrawablePtr pPriv;
+    CARD64 ust = 0;
+    BoxRec box;
+    RegionRec region;
+
+    pPriv = DRI2GetDrawable(pDraw);
+    if (pPriv == NULL) {
+        ErrorF("[DRI2] %s: bad drawable\n", __func__);
+        return;
+    }
+
+    pPriv->swapsPending--;
+    pPriv->swap_count++;
+
+    box.x1 = 0;
+    box.y1 = 0;
+    box.x2 = pDraw->width;
+    box.y2 = pDraw->height;
+    RegionInit(&region, &box, 0);
+    DRI2CopyRegion(pDraw, &region, DRI2BufferFakeFrontLeft,
+                   DRI2BufferFrontLeft);
+
+    ust = ((CARD64) tv_sec * 1000000) + tv_usec;
+    if (swap_complete)
+        swap_complete(client, swap_data, type, ust, frame, pPriv->swap_count);
+
+    pPriv->last_swap_msc = frame;
+    pPriv->last_swap_ust = ust;
+
+    DRI2WakeClient(client, pDraw, frame, tv_sec, tv_usec);
+}
+
+Bool
+DRI2WaitSwap(ClientPtr client, DrawablePtr pDrawable)
+{
+    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDrawable);
+
+    /* If we're currently waiting for a swap on this drawable, reset
+     * the request and suspend the client.  We only support one
+     * blocked client per drawable. */
+    if (pPriv && pPriv->swapsPending && pPriv->blockedClient == NULL) {
+        ResetCurrentRequest(client);
+        client->sequence--;
+        __DRI2BlockClient(client, pPriv);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+
+
+int
+DRI2SwapBuffers(ClientPtr client, DrawablePtr pDraw, CARD64 target_msc,
+                CARD64 divisor, CARD64 remainder, CARD64 * swap_target,
+                DRI2SwapEventPtr func, void *data)
+{
+    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
+    DRI2DrawablePtr pPriv;
+    DRI2BufferPtr pDestBuffer = NULL, pSrcBuffer = NULL;
+    int ret, i;
+    CARD64 ust, current_msc;
+
+    pPriv = DRI2GetDrawable(pDraw);
+    if (pPriv == NULL) {
+        ErrorF("[DRI2] %s: bad drawable\n", __func__);
+        return BadDrawable;
+    }
+
+    /* According to spec, return expected swapbuffers count SBC after this swap
+     * will complete. This is ignored unless we return Success, but it must be
+     * initialized on every path where we return Success or the caller will send
+     * an uninitialized value off the stack to the client. So let's initialize
+     * it as early as possible, just to be sure.
+     */
+    *swap_target = pPriv->swap_count + pPriv->swapsPending + 1;
+
+    for (i = 0; i < pPriv->bufferCount; i++) {
+        if (pPriv->buffers[i]->attachment == DRI2BufferFrontLeft)
+            pDestBuffer = (DRI2BufferPtr) pPriv->buffers[i];
+        if (pPriv->buffers[i]->attachment == DRI2BufferBackLeft)
+            pSrcBuffer = (DRI2BufferPtr) pPriv->buffers[i];
+    }
+    if (pSrcBuffer == NULL || pDestBuffer == NULL) {
+        ErrorF("[DRI2] %s: drawable has no back or front?\n", __func__);
+        return BadDrawable;
+    }
+
+    /* Old DDX or no swap interval, just blit */
+    if (!ds->ScheduleSwap || !pPriv->swap_interval) {
+        BoxRec box;
+        RegionRec region;
+
+        box.x1 = 0;
+        box.y1 = 0;
+        box.x2 = pDraw->width;
+        box.y2 = pDraw->height;
+        RegionInit(&region, &box, 0);
+
+        pPriv->swapsPending++;
+
+        dri2_copy_region(pDraw, &region, pDestBuffer, pSrcBuffer);
+        DRI2SwapComplete(client, pDraw, target_msc, 0, 0, DRI2_BLIT_COMPLETE,
+                         func, data);
+        return Success;
+    }
+
+    /*
+     * In the simple glXSwapBuffers case, all params will be 0, and we just
+     * need to schedule a swap for the last swap target + the swap interval.
+     */
+    if (target_msc == 0 && divisor == 0 && remainder == 0) {
+        /* If the current vblank count of the drawable's crtc is lower
+         * than the count stored in last_swap_target from a previous swap
+         * then reinitialize last_swap_target to the current crtc's msc,
+         * otherwise the swap will hang. This will happen if the drawable
+         * is moved to a crtc with a lower refresh rate, or a crtc that just
+         * got enabled.
+         */
+        if (ds->GetMSC) {
+            if (!(*ds->GetMSC) (pDraw, &ust, &current_msc))
+                pPriv->last_swap_target = 0;
+
+            if (current_msc < pPriv->last_swap_target)
+                pPriv->last_swap_target = current_msc;
+
+        }
+
+        /*
+         * Swap target for this swap is last swap target + swap interval since
+         * we have to account for the current swap count, interval, and the
+         * number of pending swaps.
+         */
+        target_msc = pPriv->last_swap_target + pPriv->swap_interval;
+
+    }
+
+    pPriv->swapsPending++;
+    ret = (*ds->ScheduleSwap) (client, pDraw, pDestBuffer, pSrcBuffer,
+                               &target_msc, divisor, remainder, func, data);
+    if (!ret) {
+        pPriv->swapsPending--;  /* didn't schedule */
+        ErrorF("[DRI2] %s: driver failed to schedule swap\n", __func__);
+        return BadDrawable;
+    }
+
+    pPriv->last_swap_target = target_msc;
+
+    DRI2InvalidateDrawableAll(pDraw);
+
+    return Success;
+}
+
+void
+DRI2SwapInterval(DrawablePtr pDrawable, int interval)
+{
+    DRI2DrawablePtr pPriv = DRI2GetDrawable(pDrawable);
+
+    if (pPriv == NULL) {
+        ErrorF("[DRI2] %s: bad drawable\n", __func__);
+        return;
+    }
+
+    /* fixme: check against arbitrary max? */
+    pPriv->swap_interval = interval;
+}
+
+int
+DRI2GetMSC(DrawablePtr pDraw, CARD64 * ust, CARD64 * msc, CARD64 * sbc)
+{
+    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
+    DRI2DrawablePtr pPriv;
+    Bool ret;
+
+    pPriv = DRI2GetDrawable(pDraw);
+    if (pPriv == NULL) {
+        ErrorF("[DRI2] %s: bad drawable\n", __func__);
+        return BadDrawable;
+    }
+
+    if (!ds->GetMSC) {
+        *ust = 0;
+        *msc = 0;
+        *sbc = pPriv->swap_count;
+        return Success;
+    }
+
+    /*
+     * Spec needs to be updated to include unmapped or redirected
+     * drawables
+     */
+
+    ret = (*ds->GetMSC) (pDraw, ust, msc);
+    if (!ret)
+        return BadDrawable;
+
+    *sbc = pPriv->swap_count;
+
+    return Success;
+}
+
+int
+DRI2WaitMSC(ClientPtr client, DrawablePtr pDraw, CARD64 target_msc,
+            CARD64 divisor, CARD64 remainder)
+{
+    DRI2ScreenPtr ds = DRI2GetScreen(pDraw->pScreen);
+    DRI2DrawablePtr pPriv;
+    Bool ret;
+
+    pPriv = DRI2GetDrawable(pDraw);
+    if (pPriv == NULL)
+        return BadDrawable;
+
+    /* Old DDX just completes immediately */
+    if (!ds->ScheduleWaitMSC) {
+        DRI2WaitMSCComplete(client, pDraw, target_msc, 0, 0);
+
+        return Success;
+    }
+
+    ret =
+        (*ds->ScheduleWaitMSC) (client, pDraw, target_msc, divisor, remainder);
+    if (!ret)
+        return BadDrawable;
+
+    return Success;
+}
+
+int
+DRI2WaitSBC(ClientPtr client, DrawablePtr pDraw, CARD64 target_sbc)
+{
+    DRI2DrawablePtr pPriv;
+
+    pPriv = DRI2GetDrawable(pDraw);
+    if (pPriv == NULL)
+        return BadDrawable;
+
+    /* target_sbc == 0 means to block until all pending swaps are
+     * finished. Recalculate target_sbc to get that behaviour.
+     */
+    if (target_sbc == 0)
+        target_sbc = pPriv->swap_count + pPriv->swapsPending;
+
+    /* If current swap count already >= target_sbc, reply and
+     * return immediately with (ust, msc, sbc) triplet of
+     * most recent completed swap.
+     */
+    if (pPriv->swap_count >= target_sbc) {
+        ProcDRI2WaitMSCReply(client, pPriv->last_swap_ust,
+                             pPriv->last_swap_msc, pPriv->swap_count);
+        return Success;
+    }
+
+    pPriv->target_sbc = target_sbc;
+    __DRI2BlockClient(client, pPriv);
+
+    return Success;
+}
+
+Bool
+DRI2HasSwapControl(ScreenPtr pScreen)
+{
+    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
+
+    return ds->ScheduleSwap && ds->GetMSC;
+}
+
+Bool
+DRI2Connect(ClientPtr client, ScreenPtr pScreen,
+            unsigned int driverType, int *fd,
+            const char **driverName, const char **deviceName)
+{
+    DRI2ScreenPtr ds;
+    uint32_t driver_id = driverType & 0xffff;
+
+    if (!dixPrivateKeyRegistered(dri2ScreenPrivateKey) ||
+        !(ds = DRI2GetScreen(pScreen)))
+        return FALSE;
+
+    if (driver_id)
+        ErrorF("Add support for driver id when requested!\n");
+
+    if (driver_id >= ds->numDrivers ||
+        !ds->driverNames[driver_id])
+        return FALSE;
+
+    *driverName = ds->driverNames[driver_id];
+    *deviceName = ds->deviceName;
+    *fd = ds->fd;
+
+    return TRUE;
+}
+
+static int
+DRI2AuthMagic (ScreenPtr pScreen, uint32_t magic)
+{
+    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
+    if (ds == NULL)
+        return -EINVAL;
+
+    return (*ds->LegacyAuthMagic) (ds->fd, magic);
+}
+
+Bool
+DRI2Authenticate(ClientPtr client, ScreenPtr pScreen, uint32_t magic)
+{
+    DRI2ScreenPtr ds;
+
+    ds = DRI2GetScreen(pScreen);
+    if (ds == NULL)
+        return FALSE;
+
+    if ((*ds->AuthMagic)(pScreen, magic))
+        return FALSE;
+    return TRUE;
+}
+
+static int
+DRI2ConfigNotify(WindowPtr pWin, int x, int y, int w, int h, int bw,
+                 WindowPtr pSib)
+{
+    DrawablePtr pDraw = (DrawablePtr) pWin;
+    ScreenPtr pScreen = pDraw->pScreen;
+    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
+    DRI2DrawablePtr dd = DRI2GetDrawable(pDraw);
+    int ret;
+
+    if (ds->ConfigNotify) {
+        pScreen->ConfigNotify = ds->ConfigNotify;
+
+        ret = (*pScreen->ConfigNotify) (pWin, x, y, w, h, bw, pSib);
+
+        ds->ConfigNotify = pScreen->ConfigNotify;
+        pScreen->ConfigNotify = DRI2ConfigNotify;
+        if (ret)
+            return ret;
+    }
+
+    if (!dd || (dd->width == w && dd->height == h))
+        return Success;
+
+    DRI2InvalidateDrawable(pDraw);
+    return Success;
+}
+
+static void
+DRI2SetWindowPixmap(WindowPtr pWin, PixmapPtr pPix)
+{
+    DrawablePtr pDraw = (DrawablePtr) pWin;
+    ScreenPtr pScreen = pDraw->pScreen;
+    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
+
+    pScreen->SetWindowPixmap = ds->SetWindowPixmap;
+    (*pScreen->SetWindowPixmap) (pWin, pPix);
+    ds->SetWindowPixmap = pScreen->SetWindowPixmap;
+    pScreen->SetWindowPixmap = DRI2SetWindowPixmap;
+
+    DRI2InvalidateDrawableAll(pDraw);
+}
+
+Bool
+DRI2ScreenInit(ScreenPtr pScreen, DRI2InfoPtr info)
+{
+    DRI2ScreenPtr ds;
+
+    const char *driverTypeNames[] = {
+        "DRI",                  /* DRI2DriverDRI */
+        "VDPAU",                /* DRI2DriverVDPAU */
+    };
+    unsigned int i;
+    CARD8 cur_minor;
+
+    if (info->version < 3)
+        return FALSE;
+
+    if (!dixRegisterPrivateKey(&dri2ScreenPrivateKeyRec, PRIVATE_SCREEN, 0))
+        return FALSE;
+
+    if (!dixRegisterPrivateKey(&dri2WindowPrivateKeyRec, PRIVATE_WINDOW, 0))
+        return FALSE;
+
+    if (!dixRegisterPrivateKey(&dri2PixmapPrivateKeyRec, PRIVATE_PIXMAP, 0))
+        return FALSE;
+
+    ds = calloc(1, sizeof *ds);
+    if (!ds)
+        return FALSE;
+
+    ds->screen = pScreen;
+    ds->fd = info->fd;
+    ds->deviceName = info->deviceName;
+    dri2_major = 1;
+
+    ds->CreateBuffer = info->CreateBuffer;
+    ds->DestroyBuffer = info->DestroyBuffer;
+    ds->CopyRegion = info->CopyRegion;
+
+    if (info->version >= 4) {
+        ds->ScheduleSwap = info->ScheduleSwap;
+        ds->ScheduleWaitMSC = info->ScheduleWaitMSC;
+        ds->GetMSC = info->GetMSC;
+        cur_minor = 3;
+    }
+    else {
+        cur_minor = 1;
+    }
+
+    if (info->version >= 8) {
+        ds->AuthMagic = info->AuthMagic2;
+    }
+    if (info->version >= 5) {
+        ds->LegacyAuthMagic = info->AuthMagic;
+    }
+
+    if (info->version >= 6) {
+        ds->ReuseBufferNotify = info->ReuseBufferNotify;
+        ds->SwapLimitValidate = info->SwapLimitValidate;
+    }
+
+    if (info->version >= 7) {
+        ds->GetParam = info->GetParam;
+        cur_minor = 4;
+    }
+
+    if (info->version >= 9) {
+        ds->CreateBuffer2 = info->CreateBuffer2;
+        ds->DestroyBuffer2 = info->DestroyBuffer2;
+        ds->CopyRegion2 = info->CopyRegion2;
+    }
+
+    /*
+     * if the driver doesn't provide an AuthMagic function or the info struct
+     * version is too low, call through LegacyAuthMagic
+     */
+    if (!ds->AuthMagic) {
+        ds->AuthMagic = DRI2AuthMagic;
+    }
+
+    /* Initialize minor if needed and set to minimum provied by DDX */
+    if (!dri2_minor || dri2_minor > cur_minor)
+        dri2_minor = cur_minor;
+
+    if (info->version == 3 || info->numDrivers == 0) {
+        /* Driver too old: use the old-style driverName field */
+        ds->numDrivers = 1;
+        ds->driverNames = malloc(sizeof(*ds->driverNames));
+        if (!ds->driverNames)
+            goto err_out;
+        ds->driverNames[0] = info->driverName;
+    }
+    else {
+        ds->numDrivers = info->numDrivers;
+        ds->driverNames = malloc(info->numDrivers * sizeof(*ds->driverNames));
+        if (!ds->driverNames)
+            goto err_out;
+        memcpy(ds->driverNames, info->driverNames,
+               info->numDrivers * sizeof(*ds->driverNames));
+    }
+
+    dixSetPrivate(&pScreen->devPrivates, dri2ScreenPrivateKey, ds);
+
+    ds->ConfigNotify = pScreen->ConfigNotify;
+    pScreen->ConfigNotify = DRI2ConfigNotify;
+
+    ds->SetWindowPixmap = pScreen->SetWindowPixmap;
+    pScreen->SetWindowPixmap = DRI2SetWindowPixmap;
+
+    ErrorF("[DRI2] Setup complete\n");
+    for (i = 0; i < sizeof(driverTypeNames) / sizeof(driverTypeNames[0]); i++) {
+        if (i < ds->numDrivers && ds->driverNames[i]) {
+            ErrorF("[DRI2]   %s driver: %s\n", driverTypeNames[i], ds->driverNames[i]);
+        }
+    }
+
+    return TRUE;
+
+ err_out:
+    ErrorF("[DRI2] Initialization failed for info version %d.\n", info->version);
+    free(ds);
+    return FALSE;
+}
+
+void
+DRI2CloseScreen(ScreenPtr pScreen)
+{
+    DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
+
+    pScreen->ConfigNotify = ds->ConfigNotify;
+    pScreen->SetWindowPixmap = ds->SetWindowPixmap;
+
+    free(ds->driverNames);
+    free(ds);
+    dixSetPrivate(&pScreen->devPrivates, dri2ScreenPrivateKey, NULL);
+}
+
+/* Called by InitExtensions() */
+Bool
+DRI2ModuleSetup(void)
+{
+    dri2DrawableRes = CreateNewResourceType(DRI2DrawableGone, "DRI2Drawable");
+    if (!dri2DrawableRes)
+        return FALSE;
+
+    return TRUE;
+}
+
+void
+DRI2Version(int *major, int *minor)
+{
+    if (major != NULL)
+        *major = 1;
+
+    if (minor != NULL)
+        *minor = 2;
+}
+
+int
+DRI2GetParam(ClientPtr client,
+             DrawablePtr drawable,
+             CARD64 param,
+             BOOL *is_param_recognized,
+             CARD64 *value)
+{
+    char high_byte = (param >> 24);
+
+    switch (high_byte) {
+    case 0:
+        /* Parameter names whose high_byte is 0 are reserved for the X
+         * server. The server currently recognizes no parameters.
+         */
+        goto not_recognized;
+    case 1:
+        /* Parameter names whose high byte is 1 are reserved for the DDX. */
+        goto not_recognized;
+    default:
+        /* Other parameter names are reserved for future use. They are never
+         * recognized.
+         */
+        goto not_recognized;
+    }
+
+not_recognized:
+    *is_param_recognized = FALSE;
+    return Success;
+}
--- /dev/null
+++ b/hw/xmir/dri2/dri2.h
@@ -0,0 +1,364 @@
+/*
+ * Copyright © 2007 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Kristian Høgsberg (krh@redhat.com)
+ */
+
+#ifndef _DRI2_H_
+#define _DRI2_H_
+
+#include <X11/extensions/dri2tokens.h>
+
+/* Version 2 structure (with format at the end) */
+typedef struct {
+    unsigned int attachment;
+    unsigned int name;
+    unsigned int pitch;
+    unsigned int cpp;
+    unsigned int flags;
+    unsigned int format;
+    void *driverPrivate;
+} DRI2BufferRec, *DRI2BufferPtr;
+
+extern CARD8 dri2_major;        /* version of DRI2 supported by DDX */
+extern CARD8 dri2_minor;
+
+typedef DRI2BufferRec DRI2Buffer2Rec, *DRI2Buffer2Ptr;
+typedef void (*DRI2SwapEventPtr) (ClientPtr client, void *data, int type,
+                                  CARD64 ust, CARD64 msc, CARD32 sbc);
+
+typedef DRI2BufferPtr(*DRI2CreateBuffersProcPtr) (DrawablePtr pDraw,
+                                                  unsigned int *attachments,
+                                                  int count);
+typedef void (*DRI2DestroyBuffersProcPtr) (DrawablePtr pDraw,
+                                           DRI2BufferPtr buffers, int count);
+typedef void (*DRI2CopyRegionProcPtr) (DrawablePtr pDraw,
+                                       RegionPtr pRegion,
+                                       DRI2BufferPtr pDestBuffer,
+                                       DRI2BufferPtr pSrcBuffer);
+typedef void (*DRI2WaitProcPtr) (WindowPtr pWin, unsigned int sequence);
+typedef int (*DRI2AuthMagicProcPtr) (int fd, uint32_t magic);
+typedef int (*DRI2AuthMagic2ProcPtr) (ScreenPtr pScreen, uint32_t magic);
+
+/**
+ * Schedule a buffer swap
+ *
+ * This callback is used to support glXSwapBuffers and the OML_sync_control
+ * extension (see it for a description of the params).
+ *
+ * Drivers should queue an event for the frame count that satisfies the
+ * parameters passed in.  If the event is in the future (i.e. the conditions
+ * aren't currently satisfied), the server may block the client at the next
+ * GLX request using DRI2WaitSwap. When the event arrives, drivers should call
+ * \c DRI2SwapComplete, which will handle waking the client and returning
+ * the appropriate data.
+ *
+ * The DDX is responsible for doing a flip, exchange, or blit of the swap
+ * when the corresponding event arrives.  The \c DRI2CanFlip and
+ * \c DRI2CanExchange functions can be used as helpers for this purpose.
+ *
+ * \param client client pointer (used for block/unblock)
+ * \param pDraw drawable whose count we want
+ * \param pDestBuffer current front buffer
+ * \param pSrcBuffer current back buffer
+ * \param target_msc frame count to wait for
+ * \param divisor divisor for condition equation
+ * \param remainder remainder for division equation
+ * \param func function to call when the swap completes
+ * \param data data for the callback \p func.
+ */
+typedef int (*DRI2ScheduleSwapProcPtr) (ClientPtr client,
+                                        DrawablePtr pDraw,
+                                        DRI2BufferPtr pDestBuffer,
+                                        DRI2BufferPtr pSrcBuffer,
+                                        CARD64 * target_msc,
+                                        CARD64 divisor,
+                                        CARD64 remainder,
+                                        DRI2SwapEventPtr func, void *data);
+typedef DRI2BufferPtr(*DRI2CreateBufferProcPtr) (DrawablePtr pDraw,
+                                                 unsigned int attachment,
+                                                 unsigned int format);
+typedef void (*DRI2DestroyBufferProcPtr) (DrawablePtr pDraw,
+                                          DRI2BufferPtr buffer);
+/**
+ * Notifies driver when DRI2GetBuffers reuses a dri2 buffer.
+ *
+ * Driver may rename the dri2 buffer in this notify if it is required.
+ *
+ * \param pDraw drawable whose count we want
+ * \param buffer buffer that will be returned to client
+ */
+typedef void (*DRI2ReuseBufferNotifyProcPtr) (DrawablePtr pDraw,
+                                              DRI2BufferPtr buffer);
+/**
+ * Get current media stamp counter values
+ *
+ * This callback is used to support the SGI_video_sync and OML_sync_control
+ * extensions.
+ *
+ * Drivers should return the current frame counter and the timestamp from
+ * when the returned frame count was last incremented.
+ *
+ * The count should correspond to the screen where the drawable is currently
+ * visible.  If the drawable isn't visible (e.g. redirected), the server
+ * should return BadDrawable to the client, pending GLX spec updates to
+ * define this behavior.
+ *
+ * \param pDraw drawable whose count we want
+ * \param ust timestamp from when the count was last incremented.
+ * \param mst current frame count
+ */
+typedef int (*DRI2GetMSCProcPtr) (DrawablePtr pDraw, CARD64 * ust,
+                                  CARD64 * msc);
+/**
+ * Schedule a frame count related wait
+ *
+ * This callback is used to support the SGI_video_sync and OML_sync_control
+ * extensions.  See those specifications for details on how to handle
+ * the divisor and remainder parameters.
+ *
+ * Drivers should queue an event for the frame count that satisfies the
+ * parameters passed in.  If the event is in the future (i.e. the conditions
+ * aren't currently satisfied), the driver should block the client using
+ * \c DRI2BlockClient.  When the event arrives, drivers should call
+ * \c DRI2WaitMSCComplete, which will handle waking the client and returning
+ * the appropriate data.
+ *
+ * \param client client pointer (used for block/unblock)
+ * \param pDraw drawable whose count we want
+ * \param target_msc frame count to wait for
+ * \param divisor divisor for condition equation
+ * \param remainder remainder for division equation
+ */
+typedef int (*DRI2ScheduleWaitMSCProcPtr) (ClientPtr client,
+                                           DrawablePtr pDraw,
+                                           CARD64 target_msc,
+                                           CARD64 divisor, CARD64 remainder);
+
+typedef void (*DRI2InvalidateProcPtr) (DrawablePtr pDraw, void *data, XID id);
+
+/**
+ * DRI2 calls this hook when ever swap_limit is going to be changed. Default
+ * implementation for the hook only accepts one as swap_limit. If driver can
+ * support other swap_limits it has to implement supported limits with this
+ * callback.
+ *
+ * \param pDraw drawable whos swap_limit is going to be changed
+ * \param swap_limit new swap_limit that going to be set
+ * \return TRUE if limit is support, FALSE if not.
+ */
+typedef Bool (*DRI2SwapLimitValidateProcPtr) (DrawablePtr pDraw,
+                                              int swap_limit);
+
+typedef DRI2BufferPtr(*DRI2CreateBuffer2ProcPtr) (ScreenPtr pScreen,
+                                                  DrawablePtr pDraw,
+                                                  unsigned int attachment,
+                                                  unsigned int format);
+typedef void (*DRI2DestroyBuffer2ProcPtr) (ScreenPtr pScreen, DrawablePtr pDraw,
+                                          DRI2BufferPtr buffer);
+
+typedef void (*DRI2CopyRegion2ProcPtr) (ScreenPtr pScreen, DrawablePtr pDraw,
+                                        RegionPtr pRegion,
+                                        DRI2BufferPtr pDestBuffer,
+                                        DRI2BufferPtr pSrcBuffer);
+
+/**
+ * \brief Get the value of a parameter.
+ *
+ * The parameter's \a value is looked up on the screen associated with
+ * \a pDrawable.
+ *
+ * \return \c Success or error code.
+ */
+typedef int (*DRI2GetParamProcPtr) (ClientPtr client,
+                                    DrawablePtr pDrawable,
+                                    CARD64 param,
+                                    BOOL *is_param_recognized,
+                                    CARD64 *value);
+
+/**
+ * Version of the DRI2InfoRec structure defined in this header
+ */
+#define DRI2INFOREC_VERSION 9
+
+typedef struct {
+    unsigned int version;       /**< Version of this struct */
+    int fd;
+    const char *driverName;
+    const char *deviceName;
+
+    DRI2CreateBufferProcPtr CreateBuffer;
+    DRI2DestroyBufferProcPtr DestroyBuffer;
+    DRI2CopyRegionProcPtr CopyRegion;
+    DRI2WaitProcPtr Wait;
+
+    /* added in version 4 */
+
+    DRI2ScheduleSwapProcPtr ScheduleSwap;
+    DRI2GetMSCProcPtr GetMSC;
+    DRI2ScheduleWaitMSCProcPtr ScheduleWaitMSC;
+
+    /* number of drivers in the driverNames array */
+    unsigned int numDrivers;
+    /* array of driver names, indexed by DRI2Driver* driver types */
+    /* a name of NULL means that driver is not supported */
+    const char *const *driverNames;
+
+    /* added in version 5 */
+
+    DRI2AuthMagicProcPtr AuthMagic;
+
+    /* added in version 6 */
+
+    DRI2ReuseBufferNotifyProcPtr ReuseBufferNotify;
+    DRI2SwapLimitValidateProcPtr SwapLimitValidate;
+
+    /* added in version 7 */
+    DRI2GetParamProcPtr GetParam;
+
+    /* added in version 8 */
+    /* AuthMagic callback which passes extra context */
+    /* If this is NULL the AuthMagic callback is used */
+    /* If this is non-NULL the AuthMagic callback is ignored */
+    DRI2AuthMagic2ProcPtr AuthMagic2;
+
+    /* added in version 9 */
+    DRI2CreateBuffer2ProcPtr CreateBuffer2;
+    DRI2DestroyBuffer2ProcPtr DestroyBuffer2;
+    DRI2CopyRegion2ProcPtr CopyRegion2;
+} DRI2InfoRec, *DRI2InfoPtr;
+
+Bool DRI2ScreenInit(ScreenPtr pScreen, DRI2InfoPtr info);
+
+void DRI2CloseScreen(ScreenPtr pScreen);
+
+Bool DRI2HasSwapControl(ScreenPtr pScreen);
+
+Bool DRI2Connect(ClientPtr client, ScreenPtr pScreen,
+                                  unsigned int driverType,
+                                  int *fd,
+                                  const char **driverName,
+                                  const char **deviceName);
+
+Bool DRI2Authenticate(ClientPtr client, ScreenPtr pScreen, uint32_t magic);
+
+int DRI2CreateDrawable(ClientPtr client,
+                                        DrawablePtr pDraw,
+                                        XID id,
+                                        DRI2InvalidateProcPtr invalidate,
+                                        void *priv);
+
+int DRI2CreateDrawable2(ClientPtr client,
+                                         DrawablePtr pDraw,
+                                         XID id,
+                                         DRI2InvalidateProcPtr invalidate,
+                                         void *priv,
+                                         XID *dri2_id_out);
+
+DRI2BufferPtr *DRI2GetBuffers(DrawablePtr pDraw,
+                                               int *width,
+                                               int *height,
+                                               unsigned int *attachments,
+                                               int count, int *out_count);
+
+int DRI2CopyRegion(DrawablePtr pDraw,
+                                    RegionPtr pRegion,
+                                    unsigned int dest, unsigned int src);
+
+/**
+ * Determine the major and minor version of the DRI2 extension.
+ *
+ * Provides a mechanism to other modules (e.g., 2D drivers) to determine the
+ * version of the DRI2 extension.  While it is possible to peek directly at
+ * the \c XF86ModuleData from a layered module, such a module will fail to
+ * load (due to an unresolved symbol) if the DRI2 extension is not loaded.
+ *
+ * \param major  Location to store the major verion of the DRI2 extension
+ * \param minor  Location to store the minor verion of the DRI2 extension
+ *
+ * \note
+ * This interface was added some time after the initial release of the DRI2
+ * module.  Layered modules that wish to use this interface must first test
+ * its existance by calling \c xf86LoaderCheckSymbol.
+ */
+void DRI2Version(int *major, int *minor);
+
+DRI2BufferPtr *DRI2GetBuffersWithFormat(DrawablePtr pDraw,
+                                                         int *width,
+                                                         int *height,
+                                                         unsigned int
+                                                         *attachments,
+                                                         int count,
+                                                         int *out_count);
+
+void DRI2SwapInterval(DrawablePtr pDrawable, int interval);
+Bool DRI2SwapLimit(DrawablePtr pDraw, int swap_limit);
+int DRI2SwapBuffers(ClientPtr client, DrawablePtr pDrawable,
+                                     CARD64 target_msc, CARD64 divisor,
+                                     CARD64 remainder, CARD64 * swap_target,
+                                     DRI2SwapEventPtr func, void *data);
+Bool DRI2WaitSwap(ClientPtr client, DrawablePtr pDrawable);
+
+int DRI2GetMSC(DrawablePtr pDrawable, CARD64 * ust,
+                                CARD64 * msc, CARD64 * sbc);
+int DRI2WaitMSC(ClientPtr client, DrawablePtr pDrawable,
+                                 CARD64 target_msc, CARD64 divisor,
+                                 CARD64 remainder);
+int ProcDRI2WaitMSCReply(ClientPtr client, CARD64 ust,
+                                          CARD64 msc, CARD64 sbc);
+int DRI2WaitSBC(ClientPtr client, DrawablePtr pDraw,
+                                 CARD64 target_sbc);
+Bool DRI2ThrottleClient(ClientPtr client, DrawablePtr pDraw);
+
+Bool DRI2CanFlip(DrawablePtr pDraw);
+
+Bool DRI2CanExchange(DrawablePtr pDraw);
+
+/* Note: use *only* for MSC related waits */
+void DRI2BlockClient(ClientPtr client, DrawablePtr pDraw);
+
+void DRI2SwapComplete(ClientPtr client, DrawablePtr pDraw,
+                                       int frame, unsigned int tv_sec,
+                                       unsigned int tv_usec, int type,
+                                       DRI2SwapEventPtr swap_complete,
+                                       void *swap_data);
+void DRI2WaitMSCComplete(ClientPtr client, DrawablePtr pDraw,
+                                          int frame, unsigned int tv_sec,
+                                          unsigned int tv_usec);
+
+int DRI2GetParam(ClientPtr client,
+                                  DrawablePtr pDrawable,
+                                  CARD64 param,
+                                  BOOL *is_param_recognized,
+                                  CARD64 *value);
+
+void DRI2ExtensionInit(void);
+extern Bool noDRI2Extension;
+
+#endif
--- /dev/null
+++ b/hw/xmir/dri2/dri2ext.c
@@ -0,0 +1,683 @@
+/*
+ * Copyright © 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Kristian Høgsberg (krh@redhat.com)
+ */
+
+#include <dix-config.h>
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include <X11/extensions/dri2proto.h>
+#include <X11/extensions/xfixeswire.h>
+#include "dixstruct.h"
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "extnsionst.h"
+#include "xfixes.h"
+#include "dri2.h"
+#include "dri2int.h"
+#include "protocol-versions.h"
+
+static int DRI2EventBase;
+
+
+static Bool
+validDrawable(ClientPtr client, XID drawable, Mask access_mode,
+              DrawablePtr *pDrawable, int *status)
+{
+    *status = dixLookupDrawable(pDrawable, drawable, client,
+                                M_DRAWABLE_WINDOW | M_DRAWABLE_PIXMAP,
+                                access_mode);
+    if (*status != Success) {
+        client->errorValue = drawable;
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static int
+ProcDRI2QueryVersion(ClientPtr client)
+{
+    REQUEST(xDRI2QueryVersionReq);
+    xDRI2QueryVersionReply rep = {
+        .type = X_Reply,
+        .sequenceNumber = client->sequence,
+        .length = 0,
+        .majorVersion = dri2_major,
+        .minorVersion = dri2_minor
+    };
+
+    if (client->swapped)
+        swaps(&stuff->length);
+
+    REQUEST_SIZE_MATCH(xDRI2QueryVersionReq);
+
+    if (client->swapped) {
+        swaps(&rep.sequenceNumber);
+        swapl(&rep.length);
+        swapl(&rep.majorVersion);
+        swapl(&rep.minorVersion);
+    }
+
+    WriteToClient(client, sizeof(xDRI2QueryVersionReply), &rep);
+
+    return Success;
+}
+
+static int
+ProcDRI2Connect(ClientPtr client)
+{
+    REQUEST(xDRI2ConnectReq);
+    xDRI2ConnectReply rep = {
+        .type = X_Reply,
+        .sequenceNumber = client->sequence,
+        .length = 0,
+        .driverNameLength = 0,
+        .deviceNameLength = 0
+    };
+    DrawablePtr pDraw;
+    int fd, status;
+    const char *driverName;
+    const char *deviceName;
+
+    REQUEST_SIZE_MATCH(xDRI2ConnectReq);
+    if (!validDrawable(client, stuff->window, DixGetAttrAccess,
+                       &pDraw, &status))
+        return status;
+
+    if (!DRI2Connect(client, pDraw->pScreen,
+                     stuff->driverType, &fd, &driverName, &deviceName))
+        goto fail;
+
+    rep.driverNameLength = strlen(driverName);
+    rep.deviceNameLength = strlen(deviceName);
+    rep.length = (rep.driverNameLength + 3) / 4 +
+        (rep.deviceNameLength + 3) / 4;
+
+ fail:
+    WriteToClient(client, sizeof(xDRI2ConnectReply), &rep);
+    WriteToClient(client, rep.driverNameLength, driverName);
+    WriteToClient(client, rep.deviceNameLength, deviceName);
+
+    return Success;
+}
+
+static int
+ProcDRI2Authenticate(ClientPtr client)
+{
+    REQUEST(xDRI2AuthenticateReq);
+    xDRI2AuthenticateReply rep;
+    DrawablePtr pDraw;
+    int status;
+
+    REQUEST_SIZE_MATCH(xDRI2AuthenticateReq);
+    if (!validDrawable(client, stuff->window, DixGetAttrAccess,
+                       &pDraw, &status))
+        return status;
+
+    rep = (xDRI2AuthenticateReply) {
+        .type = X_Reply,
+        .sequenceNumber = client->sequence,
+        .length = 0,
+        .authenticated = DRI2Authenticate(client, pDraw->pScreen, stuff->magic)
+    };
+    WriteToClient(client, sizeof(xDRI2AuthenticateReply), &rep);
+
+    return Success;
+}
+
+static void
+DRI2InvalidateBuffersEvent(DrawablePtr pDraw, void *priv, XID id)
+{
+    ClientPtr client = priv;
+    xDRI2InvalidateBuffers event = {
+        .type = DRI2EventBase + DRI2_InvalidateBuffers,
+        .drawable = id
+    };
+
+    WriteEventsToClient(client, 1, (xEvent *) &event);
+}
+
+static int
+ProcDRI2CreateDrawable(ClientPtr client)
+{
+    REQUEST(xDRI2CreateDrawableReq);
+    DrawablePtr pDrawable;
+    int status;
+
+    REQUEST_SIZE_MATCH(xDRI2CreateDrawableReq);
+
+    if (!validDrawable(client, stuff->drawable, DixAddAccess,
+                       &pDrawable, &status))
+        return status;
+
+    status = DRI2CreateDrawable(client, pDrawable, stuff->drawable,
+                                DRI2InvalidateBuffersEvent, client);
+    if (status != Success)
+        return status;
+
+    return Success;
+}
+
+static int
+ProcDRI2DestroyDrawable(ClientPtr client)
+{
+    REQUEST(xDRI2DestroyDrawableReq);
+    DrawablePtr pDrawable;
+    int status;
+
+    REQUEST_SIZE_MATCH(xDRI2DestroyDrawableReq);
+    if (!validDrawable(client, stuff->drawable, DixRemoveAccess,
+                       &pDrawable, &status))
+        return status;
+
+    return Success;
+}
+
+static int
+send_buffers_reply(ClientPtr client, DrawablePtr pDrawable,
+                   DRI2BufferPtr * buffers, int count, int width, int height)
+{
+    xDRI2GetBuffersReply rep;
+    int skip = 0;
+    int i;
+
+    if (buffers == NULL)
+        return BadAlloc;
+
+    if (pDrawable->type == DRAWABLE_WINDOW) {
+        for (i = 0; i < count; i++) {
+            /* Do not send the real front buffer of a window to the client.
+             */
+            if (buffers[i]->attachment == DRI2BufferFrontLeft) {
+                skip++;
+                continue;
+            }
+        }
+    }
+
+    rep = (xDRI2GetBuffersReply) {
+        .type = X_Reply,
+        .sequenceNumber = client->sequence,
+        .length = (count - skip) * sizeof(xDRI2Buffer) / 4,
+        .width = width,
+        .height = height,
+        .count = count - skip
+    };
+    WriteToClient(client, sizeof(xDRI2GetBuffersReply), &rep);
+
+    for (i = 0; i < count; i++) {
+        xDRI2Buffer buffer;
+
+        /* Do not send the real front buffer of a window to the client.
+         */
+        if ((pDrawable->type == DRAWABLE_WINDOW)
+            && (buffers[i]->attachment == DRI2BufferFrontLeft)) {
+            continue;
+        }
+
+        buffer.attachment = buffers[i]->attachment;
+        buffer.name = buffers[i]->name;
+        buffer.pitch = buffers[i]->pitch;
+        buffer.cpp = buffers[i]->cpp;
+        buffer.flags = buffers[i]->flags;
+        WriteToClient(client, sizeof(xDRI2Buffer), &buffer);
+    }
+    return Success;
+}
+
+static int
+ProcDRI2GetBuffers(ClientPtr client)
+{
+    REQUEST(xDRI2GetBuffersReq);
+    DrawablePtr pDrawable;
+    DRI2BufferPtr *buffers;
+    int status, width, height, count;
+    unsigned int *attachments;
+
+    REQUEST_FIXED_SIZE(xDRI2GetBuffersReq, stuff->count * 4);
+    if (!validDrawable(client, stuff->drawable, DixReadAccess | DixWriteAccess,
+                       &pDrawable, &status))
+        return status;
+
+    if (DRI2ThrottleClient(client, pDrawable))
+        return Success;
+
+    attachments = (unsigned int *) &stuff[1];
+    buffers = DRI2GetBuffers(pDrawable, &width, &height,
+                             attachments, stuff->count, &count);
+
+    return send_buffers_reply(client, pDrawable, buffers, count, width, height);
+
+}
+
+static int
+ProcDRI2GetBuffersWithFormat(ClientPtr client)
+{
+    REQUEST(xDRI2GetBuffersReq);
+    DrawablePtr pDrawable;
+    DRI2BufferPtr *buffers;
+    int status, width, height, count;
+    unsigned int *attachments;
+
+    REQUEST_FIXED_SIZE(xDRI2GetBuffersReq, stuff->count * (2 * 4));
+    if (!validDrawable(client, stuff->drawable, DixReadAccess | DixWriteAccess,
+                       &pDrawable, &status))
+        return status;
+
+    if (DRI2ThrottleClient(client, pDrawable))
+        return Success;
+
+    attachments = (unsigned int *) &stuff[1];
+    buffers = DRI2GetBuffersWithFormat(pDrawable, &width, &height,
+                                       attachments, stuff->count, &count);
+
+    return send_buffers_reply(client, pDrawable, buffers, count, width, height);
+}
+
+static int
+ProcDRI2CopyRegion(ClientPtr client)
+{
+    REQUEST(xDRI2CopyRegionReq);
+    xDRI2CopyRegionReply rep;
+    DrawablePtr pDrawable;
+    int status;
+    RegionPtr pRegion;
+
+    REQUEST_SIZE_MATCH(xDRI2CopyRegionReq);
+
+    if (!validDrawable(client, stuff->drawable, DixWriteAccess,
+                       &pDrawable, &status))
+        return status;
+
+    VERIFY_REGION(pRegion, stuff->region, client, DixReadAccess);
+
+    status = DRI2CopyRegion(pDrawable, pRegion, stuff->dest, stuff->src);
+    if (status != Success)
+        return status;
+
+    /* CopyRegion needs to be a round trip to make sure the X server
+     * queues the swap buffer rendering commands before the DRI client
+     * continues rendering.  The reply has a bitmask to signal the
+     * presense of optional return values as well, but we're not using
+     * that yet.
+     */
+
+    rep = (xDRI2CopyRegionReply) {
+        .type = X_Reply,
+        .sequenceNumber = client->sequence,
+        .length = 0
+    };
+
+    WriteToClient(client, sizeof(xDRI2CopyRegionReply), &rep);
+
+    return Success;
+}
+
+static void
+load_swap_reply(xDRI2SwapBuffersReply * rep, CARD64 sbc)
+{
+    rep->swap_hi = sbc >> 32;
+    rep->swap_lo = sbc & 0xffffffff;
+}
+
+static CARD64
+vals_to_card64(CARD32 lo, CARD32 hi)
+{
+    return (CARD64) hi << 32 | lo;
+}
+
+static void
+DRI2SwapEvent(ClientPtr client, void *data, int type, CARD64 ust, CARD64 msc,
+              CARD32 sbc)
+{
+    DrawablePtr pDrawable = data;
+    xDRI2BufferSwapComplete2 event = {
+        .type = DRI2EventBase + DRI2_BufferSwapComplete,
+        .event_type = type,
+        .drawable = pDrawable->id,
+        .ust_hi = (CARD64) ust >> 32,
+        .ust_lo = ust & 0xffffffff,
+        .msc_hi = (CARD64) msc >> 32,
+        .msc_lo = msc & 0xffffffff,
+        .sbc = sbc
+    };
+
+    WriteEventsToClient(client, 1, (xEvent *) &event);
+}
+
+static int
+ProcDRI2SwapBuffers(ClientPtr client)
+{
+    REQUEST(xDRI2SwapBuffersReq);
+    xDRI2SwapBuffersReply rep = {
+        .type = X_Reply,
+        .sequenceNumber = client->sequence,
+        .length = 0
+    };
+    DrawablePtr pDrawable;
+    CARD64 target_msc, divisor, remainder, swap_target;
+    int status;
+
+    REQUEST_SIZE_MATCH(xDRI2SwapBuffersReq);
+
+    if (!validDrawable(client, stuff->drawable,
+                       DixReadAccess | DixWriteAccess, &pDrawable, &status))
+        return status;
+
+    /*
+     * Ensures an out of control client can't exhaust our swap queue, and
+     * also orders swaps.
+     */
+    if (DRI2ThrottleClient(client, pDrawable))
+        return Success;
+
+    target_msc = vals_to_card64(stuff->target_msc_lo, stuff->target_msc_hi);
+    divisor = vals_to_card64(stuff->divisor_lo, stuff->divisor_hi);
+    remainder = vals_to_card64(stuff->remainder_lo, stuff->remainder_hi);
+
+    status = DRI2SwapBuffers(client, pDrawable, target_msc, divisor, remainder,
+                             &swap_target, DRI2SwapEvent, pDrawable);
+    if (status != Success)
+        return BadDrawable;
+
+    load_swap_reply(&rep, swap_target);
+
+    WriteToClient(client, sizeof(xDRI2SwapBuffersReply), &rep);
+
+    return Success;
+}
+
+static void
+load_msc_reply(xDRI2MSCReply * rep, CARD64 ust, CARD64 msc, CARD64 sbc)
+{
+    rep->ust_hi = ust >> 32;
+    rep->ust_lo = ust & 0xffffffff;
+    rep->msc_hi = msc >> 32;
+    rep->msc_lo = msc & 0xffffffff;
+    rep->sbc_hi = sbc >> 32;
+    rep->sbc_lo = sbc & 0xffffffff;
+}
+
+static int
+ProcDRI2GetMSC(ClientPtr client)
+{
+    REQUEST(xDRI2GetMSCReq);
+    xDRI2MSCReply rep = {
+        .type = X_Reply,
+        .sequenceNumber = client->sequence,
+        .length = 0
+    };
+    DrawablePtr pDrawable;
+    CARD64 ust, msc, sbc;
+    int status;
+
+    REQUEST_SIZE_MATCH(xDRI2GetMSCReq);
+
+    if (!validDrawable(client, stuff->drawable, DixReadAccess, &pDrawable,
+                       &status))
+        return status;
+
+    status = DRI2GetMSC(pDrawable, &ust, &msc, &sbc);
+    if (status != Success)
+        return status;
+
+    load_msc_reply(&rep, ust, msc, sbc);
+
+    WriteToClient(client, sizeof(xDRI2MSCReply), &rep);
+
+    return Success;
+}
+
+static int
+ProcDRI2WaitMSC(ClientPtr client)
+{
+    REQUEST(xDRI2WaitMSCReq);
+    DrawablePtr pDrawable;
+    CARD64 target, divisor, remainder;
+    int status;
+
+    /* FIXME: in restart case, client may be gone at this point */
+
+    REQUEST_SIZE_MATCH(xDRI2WaitMSCReq);
+
+    if (!validDrawable(client, stuff->drawable, DixReadAccess, &pDrawable,
+                       &status))
+        return status;
+
+    target = vals_to_card64(stuff->target_msc_lo, stuff->target_msc_hi);
+    divisor = vals_to_card64(stuff->divisor_lo, stuff->divisor_hi);
+    remainder = vals_to_card64(stuff->remainder_lo, stuff->remainder_hi);
+
+    status = DRI2WaitMSC(client, pDrawable, target, divisor, remainder);
+    if (status != Success)
+        return status;
+
+    return Success;
+}
+
+int
+ProcDRI2WaitMSCReply(ClientPtr client, CARD64 ust, CARD64 msc, CARD64 sbc)
+{
+    xDRI2MSCReply rep = {
+        .type = X_Reply,
+        .sequenceNumber = client->sequence,
+        .length = 0
+    };
+
+    load_msc_reply(&rep, ust, msc, sbc);
+
+    WriteToClient(client, sizeof(xDRI2MSCReply), &rep);
+
+    return Success;
+}
+
+static int
+ProcDRI2SwapInterval(ClientPtr client)
+{
+    REQUEST(xDRI2SwapIntervalReq);
+    DrawablePtr pDrawable;
+    int status;
+
+    /* FIXME: in restart case, client may be gone at this point */
+
+    REQUEST_SIZE_MATCH(xDRI2SwapIntervalReq);
+
+    if (!validDrawable(client, stuff->drawable, DixReadAccess | DixWriteAccess,
+                       &pDrawable, &status))
+        return status;
+
+    DRI2SwapInterval(pDrawable, stuff->interval);
+
+    return Success;
+}
+
+static int
+ProcDRI2WaitSBC(ClientPtr client)
+{
+    REQUEST(xDRI2WaitSBCReq);
+    DrawablePtr pDrawable;
+    CARD64 target;
+    int status;
+
+    REQUEST_SIZE_MATCH(xDRI2WaitSBCReq);
+
+    if (!validDrawable(client, stuff->drawable, DixReadAccess, &pDrawable,
+                       &status))
+        return status;
+
+    target = vals_to_card64(stuff->target_sbc_lo, stuff->target_sbc_hi);
+    status = DRI2WaitSBC(client, pDrawable, target);
+
+    return status;
+}
+
+static int
+ProcDRI2GetParam(ClientPtr client)
+{
+    REQUEST(xDRI2GetParamReq);
+    xDRI2GetParamReply rep = {
+        .type = X_Reply,
+        .sequenceNumber = client->sequence,
+        .length = 0
+    };
+    DrawablePtr pDrawable;
+    CARD64 value;
+    int status;
+
+    REQUEST_SIZE_MATCH(xDRI2GetParamReq);
+
+    if (!validDrawable(client, stuff->drawable, DixReadAccess,
+                       &pDrawable, &status))
+        return status;
+
+    status = DRI2GetParam(client, pDrawable, stuff->param,
+                          &rep.is_param_recognized, &value);
+    rep.value_hi = value >> 32;
+    rep.value_lo = value & 0xffffffff;
+
+    if (status != Success)
+        return status;
+
+    WriteToClient(client, sizeof(xDRI2GetParamReply), &rep);
+
+    return status;
+}
+
+static int
+ProcDRI2Dispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+
+    switch (stuff->data) {
+    case X_DRI2QueryVersion:
+        return ProcDRI2QueryVersion(client);
+    }
+
+    if (!client->local)
+        return BadRequest;
+
+    switch (stuff->data) {
+    case X_DRI2Connect:
+        return ProcDRI2Connect(client);
+    case X_DRI2Authenticate:
+        return ProcDRI2Authenticate(client);
+    case X_DRI2CreateDrawable:
+        return ProcDRI2CreateDrawable(client);
+    case X_DRI2DestroyDrawable:
+        return ProcDRI2DestroyDrawable(client);
+    case X_DRI2GetBuffers:
+        return ProcDRI2GetBuffers(client);
+    case X_DRI2CopyRegion:
+        return ProcDRI2CopyRegion(client);
+    case X_DRI2GetBuffersWithFormat:
+        return ProcDRI2GetBuffersWithFormat(client);
+    case X_DRI2SwapBuffers:
+        return ProcDRI2SwapBuffers(client);
+    case X_DRI2GetMSC:
+        return ProcDRI2GetMSC(client);
+    case X_DRI2WaitMSC:
+        return ProcDRI2WaitMSC(client);
+    case X_DRI2WaitSBC:
+        return ProcDRI2WaitSBC(client);
+    case X_DRI2SwapInterval:
+        return ProcDRI2SwapInterval(client);
+    case X_DRI2GetParam:
+        return ProcDRI2GetParam(client);
+    default:
+        return BadRequest;
+    }
+}
+
+static int
+SProcDRI2Connect(ClientPtr client)
+{
+    REQUEST(xDRI2ConnectReq);
+    xDRI2ConnectReply rep = {
+        .type = X_Reply,
+        .sequenceNumber = client->sequence,
+        .length = 0,
+        .driverNameLength = 0,
+        .deviceNameLength = 0
+    };
+
+    /* If the client is swapped, it's not local.  Talk to the hand. */
+
+    swaps(&stuff->length);
+    if (sizeof(*stuff) / 4 != client->req_len)
+        return BadLength;
+
+    swaps(&rep.sequenceNumber);
+
+    WriteToClient(client, sizeof(xDRI2ConnectReply), &rep);
+
+    return Success;
+}
+
+static int
+SProcDRI2Dispatch(ClientPtr client)
+{
+    REQUEST(xReq);
+
+    /*
+     * Only local clients are allowed DRI access, but remote clients
+     * still need these requests to find out cleanly.
+     */
+    switch (stuff->data) {
+    case X_DRI2QueryVersion:
+        return ProcDRI2QueryVersion(client);
+    case X_DRI2Connect:
+        return SProcDRI2Connect(client);
+    default:
+        return BadRequest;
+    }
+}
+
+void
+DRI2ExtensionInit(void)
+{
+    ExtensionEntry *dri2Extension;
+
+#ifdef PANORAMIX
+    if (!noPanoramiXExtension)
+        return;
+#endif
+
+    dri2Extension = AddExtension(DRI2_NAME,
+                                 DRI2NumberEvents,
+                                 DRI2NumberErrors,
+                                 ProcDRI2Dispatch,
+                                 SProcDRI2Dispatch, NULL, StandardMinorOpcode);
+
+    DRI2EventBase = dri2Extension->eventBase;
+
+    DRI2ModuleSetup();
+}
--- /dev/null
+++ b/hw/xmir/dri2/dri2int.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright © 2011 Daniel Stone
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Daniel Stone <daniel@fooishbar.org>
+ */
+
+extern Bool DRI2ModuleSetup(void);
--- /dev/null
+++ b/hw/xmir/xmir-cursor.c
@@ -0,0 +1,225 @@
+/*
+ * Copyright © 2015-2017 Canonical Ltd
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include "xmir.h"
+
+#include <mipointer.h>
+
+static DevPrivateKeyRec xmir_cursor_private_key;
+
+static void
+expand_source_and_mask(CursorPtr cursor, void *data)
+{
+    CARD32 *p, d, fg, bg;
+    CursorBitsPtr bits = cursor->bits;
+    int x, y, stride, i, bit;
+
+    p = data;
+    fg = ((cursor->foreRed & 0xff00) << 8) |
+        (cursor->foreGreen & 0xff00) | (cursor->foreGreen >> 8);
+    bg = ((cursor->backRed & 0xff00) << 8) |
+        (cursor->backGreen & 0xff00) | (cursor->backGreen >> 8);
+    stride = (bits->width / 8 + 3) & ~3;
+    for (y = 0; y < bits->height; y++)
+        for (x = 0; x < bits->width; x++) {
+            i = y * stride + x / 8;
+            bit = 1 << (x & 7);
+            if (bits->source[i] & bit)
+                d = fg;
+            else
+                d = bg;
+            if (bits->mask[i] & bit)
+                d |= 0xff000000;
+            else
+                d = 0x00000000;
+
+            *p++ = d;
+        }
+}
+
+static Bool
+xmir_realize_cursor(DeviceIntPtr device, ScreenPtr screen, CursorPtr cursor)
+{
+    return TRUE;
+}
+
+static void xmir_input_set_cursor(struct xmir_input *xmir_input,
+                                  CursorPtr cursor);
+
+static Bool
+xmir_unrealize_cursor(DeviceIntPtr device, ScreenPtr screen, CursorPtr cursor)
+{
+    struct xmir_input *xmir_input = device ? device->public.devicePrivate : NULL;
+    MirBufferStream *stream;
+
+    stream = dixGetPrivate(&cursor->devPrivates, &xmir_cursor_private_key);
+    dixSetPrivate(&cursor->devPrivates, &xmir_cursor_private_key, NULL);
+
+    if (xmir_input)
+        xmir_input_set_cursor(xmir_input, rootCursor);
+
+    if (stream)
+        mir_buffer_stream_release_sync(stream);
+
+    return TRUE;
+}
+
+static void
+xmir_input_set_cursor(struct xmir_input *xmir_input, CursorPtr cursor)
+{
+    MirGraphicsRegion region;
+    MirCursorConfiguration *config;
+    MirBufferStream *stream;
+
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+    if (!cursor) {
+        config = mir_cursor_configuration_from_name(mir_disabled_cursor_name);
+        goto apply;
+    }
+    else if (cursor == rootCursor) {
+        /* Avoid using the old style X default black cross cursor */
+        config = mir_cursor_configuration_from_name(mir_arrow_cursor_name);
+        goto apply;
+    }
+#pragma GCC diagnostic pop
+
+    stream = dixGetPrivate(&cursor->devPrivates, &xmir_cursor_private_key);
+    if (stream) {
+        mir_buffer_stream_get_graphics_region(stream, &region);
+        if (region.width != cursor->bits->width ||
+            region.height != cursor->bits->height) {
+            mir_buffer_stream_release_sync(stream);
+            stream = NULL;
+        }
+    }
+
+    if (!stream) {
+        stream = mir_connection_create_buffer_stream_sync(xmir_input->xmir_screen->conn,
+                                                          cursor->bits->width,
+                                                          cursor->bits->height,
+                                                          mir_pixel_format_argb_8888,
+                                                          mir_buffer_usage_software);
+        dixSetPrivate(&cursor->devPrivates, &xmir_cursor_private_key, stream);
+        mir_buffer_stream_get_graphics_region(stream, &region);
+    }
+
+    if (cursor->bits->argb) {
+        int y, stride;
+
+        stride = cursor->bits->width * 4;
+        for (y = 0; y < cursor->bits->height; y++)
+           memcpy(region.vaddr + y * region.stride,
+                  (char*)cursor->bits->argb + y * stride, stride);
+    }
+    else
+        expand_source_and_mask(cursor, region.vaddr);
+
+    mir_buffer_stream_swap_buffers(stream, NULL, NULL);
+    config = mir_cursor_configuration_from_buffer_stream(stream,
+                                                         cursor->bits->xhot,
+                                                         cursor->bits->yhot);
+
+apply:
+    if (!xmir_input->xmir_screen->rootless) {
+        struct xmir_window *w = xmir_window_get(xmir_input->xmir_screen->screen->root);
+        mir_window_configure_cursor(w->surface, config);
+    }
+    else if (xmir_input->focus_window)
+        mir_window_configure_cursor(xmir_input->focus_window->surface, config);
+    mir_cursor_configuration_destroy(config);
+}
+
+static void
+xmir_set_cursor(DeviceIntPtr device,
+                ScreenPtr screen, CursorPtr cursor, int x, int y)
+{
+    struct xmir_input *xmir_input;
+
+    xmir_input = device->public.devicePrivate;
+    if (xmir_input == NULL)
+        return;
+
+    xmir_input_set_cursor(xmir_input, cursor);
+}
+
+static void
+xmir_move_cursor(DeviceIntPtr device, ScreenPtr screen, int x, int y)
+{
+}
+
+static Bool
+xmir_device_cursor_initialize(DeviceIntPtr device, ScreenPtr screen)
+{
+    return TRUE;
+}
+
+static void
+xmir_device_cursor_cleanup(DeviceIntPtr device, ScreenPtr screen)
+{
+}
+
+static miPointerSpriteFuncRec xmir_pointer_sprite_funcs = {
+    xmir_realize_cursor,
+    xmir_unrealize_cursor,
+    xmir_set_cursor,
+    xmir_move_cursor,
+    xmir_device_cursor_initialize,
+    xmir_device_cursor_cleanup
+};
+
+static Bool
+xmir_cursor_off_screen(ScreenPtr *ppScreen, int *x, int *y)
+{
+    return FALSE;
+}
+
+static void
+xmir_cross_screen(ScreenPtr pScreen, Bool entering)
+{
+}
+
+static void
+xmir_pointer_warp_cursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y)
+{
+}
+
+static miPointerScreenFuncRec xmir_pointer_screen_funcs = {
+    xmir_cursor_off_screen,
+    xmir_cross_screen,
+    xmir_pointer_warp_cursor
+};
+
+Bool
+xmir_screen_init_cursor(struct xmir_screen *xmir_screen)
+{
+    if (!dixRegisterPrivateKey(&xmir_cursor_private_key,
+                               PRIVATE_CURSOR_BITS, 0))
+        return FALSE;
+
+    return miPointerInitialize(xmir_screen->screen,
+                               &xmir_pointer_sprite_funcs,
+                               &xmir_pointer_screen_funcs, TRUE);
+}
--- /dev/null
+++ b/hw/xmir/xmir-cvt.c
@@ -0,0 +1,304 @@
+/* Copied from hw/xfree86/modes/xf86cvt.c into xmir DDX and
+ * changed to generate an RRMode */
+
+/*
+ * Copyright 2005-2006 Luc Verhaegen.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * The reason for having this function in a file of its own is
+ * so that ../utils/cvt/cvt can link to it, and that xf86CVTMode
+ * code is shared directly.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <string.h>
+#include <randrstr.h>
+#include "xmir.h"
+
+/*
+ * Generate a CVT standard mode from HDisplay, VDisplay and VRefresh.
+ *
+ * These calculations are stolen from the CVT calculation spreadsheet written
+ * by Graham Loveridge. He seems to be claiming no copyright and there seems to
+ * be no license attached to this. He apparently just wants to see his name
+ * mentioned.
+ *
+ * This file can be found at http://www.vesa.org/Public/CVT/CVTd6r1.xls
+ *
+ * Comments and structure corresponds to the comments and structure of the xls.
+ * This should ease importing of future changes to the standard (not very
+ * likely though).
+ *
+ * About margins; i'm sure that they are to be the bit between HDisplay and
+ * HBlankStart, HBlankEnd and HTotal, VDisplay and VBlankStart, VBlankEnd and
+ * VTotal, where the overscan colour is shown. FB seems to call _all_ blanking
+ * outside sync "margin" for some reason. Since we prefer seeing proper
+ * blanking instead of the overscan colour, and since the Crtc* values will
+ * probably get altered after us, we will disable margins altogether. With
+ * these calculations, Margins will plainly expand H/VDisplay, and we don't
+ * want that. -- libv
+ *
+ */
+RRModePtr
+xmir_cvt(int HDisplay, int VDisplay, float VRefresh, Bool Reduced,
+             Bool Interlaced)
+{
+    /* 1) top/bottom margin size (% of height) - default: 1.8 */
+#define CVT_MARGIN_PERCENTAGE 1.8
+
+    /* 2) character cell horizontal granularity (pixels) - default 8 */
+#define CVT_H_GRANULARITY 8
+
+    /* 4) Minimum vertical porch (lines) - default 3 */
+#define CVT_MIN_V_PORCH 3
+
+    /* 4) Minimum number of vertical back porch lines - default 6 */
+#define CVT_MIN_V_BPORCH 6
+
+    /* Pixel Clock step (kHz) */
+#define CVT_CLOCK_STEP 250
+
+    Bool Margins = FALSE;
+    float VFieldRate, HPeriod;
+    int HDisplayRnd, HMargin;
+    int VDisplayRnd, VMargin, VSync;
+    float Interlace;            /* Please rename this */
+    char name[128];
+    xRRModeInfo modeinfo;
+
+    memset(&modeinfo, 0, sizeof modeinfo);
+
+    /* CVT default is 60.0Hz */
+    if (!VRefresh)
+        VRefresh = 60.0;
+
+    /* 1. Required field rate */
+    if (Interlaced)
+        VFieldRate = VRefresh * 2;
+    else
+        VFieldRate = VRefresh;
+
+    /* 2. Horizontal pixels */
+    HDisplayRnd = HDisplay - (HDisplay % CVT_H_GRANULARITY);
+
+    /* 3. Determine left and right borders */
+    if (Margins) {
+        /* right margin is actually exactly the same as left */
+        HMargin = (((float) HDisplayRnd) * CVT_MARGIN_PERCENTAGE / 100.0);
+        HMargin -= HMargin % CVT_H_GRANULARITY;
+    }
+    else
+        HMargin = 0;
+
+    /* 4. Find total active pixels */
+    modeinfo.width = HDisplayRnd + 2 * HMargin;
+
+    /* 5. Find number of lines per field */
+    if (Interlaced)
+        VDisplayRnd = VDisplay / 2;
+    else
+        VDisplayRnd = VDisplay;
+
+    /* 6. Find top and bottom margins */
+    /* nope. */
+    if (Margins)
+        /* top and bottom margins are equal again. */
+        VMargin = (((float) VDisplayRnd) * CVT_MARGIN_PERCENTAGE / 100.0);
+    else
+        VMargin = 0;
+
+    modeinfo.height = VDisplay + 2 * VMargin;
+
+    /* 7. Interlace */
+    if (Interlaced)
+        Interlace = 0.5;
+    else
+        Interlace = 0.0;
+
+    /* Determine VSync Width from aspect ratio */
+    if (!(VDisplay % 3) && ((VDisplay * 4 / 3) == HDisplay))
+        VSync = 4;
+    else if (!(VDisplay % 9) && ((VDisplay * 16 / 9) == HDisplay))
+        VSync = 5;
+    else if (!(VDisplay % 10) && ((VDisplay * 16 / 10) == HDisplay))
+        VSync = 6;
+    else if (!(VDisplay % 4) && ((VDisplay * 5 / 4) == HDisplay))
+        VSync = 7;
+    else if (!(VDisplay % 9) && ((VDisplay * 15 / 9) == HDisplay))
+        VSync = 7;
+    else                        /* Custom */
+        VSync = 10;
+
+    if (!Reduced) {             /* simplified GTF calculation */
+
+        /* 4) Minimum time of vertical sync + back porch interval (µs)
+         * default 550.0 */
+#define CVT_MIN_VSYNC_BP 550.0
+
+        /* 3) Nominal HSync width (% of line period) - default 8 */
+#define CVT_HSYNC_PERCENTAGE 8
+
+        float HBlankPercentage;
+        int VSyncAndBackPorch, VBackPorch;
+        int HBlank;
+
+        /* 8. Estimated Horizontal period */
+        HPeriod = ((float) (1000000.0 / VFieldRate - CVT_MIN_VSYNC_BP)) /
+            (VDisplayRnd + 2 * VMargin + CVT_MIN_V_PORCH + Interlace);
+
+        /* 9. Find number of lines in sync + backporch */
+        if (((int) (CVT_MIN_VSYNC_BP / HPeriod) + 1) <
+            (VSync + CVT_MIN_V_PORCH))
+            VSyncAndBackPorch = VSync + CVT_MIN_V_PORCH;
+        else
+            VSyncAndBackPorch = (int) (CVT_MIN_VSYNC_BP / HPeriod) + 1;
+
+        /* 10. Find number of lines in back porch */
+        VBackPorch = VSyncAndBackPorch - VSync;
+        (void) VBackPorch;
+
+        /* 11. Find total number of lines in vertical field */
+        modeinfo.vTotal =
+            VDisplayRnd + 2 * VMargin + VSyncAndBackPorch + Interlace +
+            CVT_MIN_V_PORCH;
+
+        /* 5) Definition of Horizontal blanking time limitation */
+        /* Gradient (%/kHz) - default 600 */
+#define CVT_M_FACTOR 600
+
+        /* Offset (%) - default 40 */
+#define CVT_C_FACTOR 40
+
+        /* Blanking time scaling factor - default 128 */
+#define CVT_K_FACTOR 128
+
+        /* Scaling factor weighting - default 20 */
+#define CVT_J_FACTOR 20
+
+#define CVT_M_PRIME CVT_M_FACTOR * CVT_K_FACTOR / 256
+#define CVT_C_PRIME (CVT_C_FACTOR - CVT_J_FACTOR) * CVT_K_FACTOR / 256 + \
+        CVT_J_FACTOR
+
+        /* 12. Find ideal blanking duty cycle from formula */
+        HBlankPercentage = CVT_C_PRIME - CVT_M_PRIME * HPeriod / 1000.0;
+
+        /* 13. Blanking time */
+        if (HBlankPercentage < 20)
+            HBlankPercentage = 20;
+
+        HBlank = modeinfo.width * HBlankPercentage / (100.0 - HBlankPercentage);
+        HBlank -= HBlank % (2 * CVT_H_GRANULARITY);
+
+        /* 14. Find total number of pixels in a line. */
+        modeinfo.hTotal = modeinfo.width + HBlank;
+
+        /* Fill in HSync values */
+        modeinfo.hSyncEnd = modeinfo.width + HBlank / 2;
+
+        modeinfo.hSyncStart = modeinfo.hSyncEnd -
+            (modeinfo.hTotal * CVT_HSYNC_PERCENTAGE) / 100;
+        modeinfo.hSyncStart += CVT_H_GRANULARITY -
+            modeinfo.hSyncStart % CVT_H_GRANULARITY;
+
+        /* Fill in VSync values */
+        modeinfo.vSyncStart = modeinfo.height + CVT_MIN_V_PORCH;
+        modeinfo.vSyncEnd = modeinfo.vSyncStart + VSync;
+
+    }
+    else {                      /* Reduced blanking */
+        /* Minimum vertical blanking interval time (µs) - default 460 */
+#define CVT_RB_MIN_VBLANK 460.0
+
+        /* Fixed number of clocks for horizontal sync */
+#define CVT_RB_H_SYNC 32.0
+
+        /* Fixed number of clocks for horizontal blanking */
+#define CVT_RB_H_BLANK 160.0
+
+        /* Fixed number of lines for vertical front porch - default 3 */
+#define CVT_RB_VFPORCH 3
+
+        int VBILines;
+
+        /* 8. Estimate Horizontal period. */
+        HPeriod = ((float) (1000000.0 / VFieldRate - CVT_RB_MIN_VBLANK)) /
+            (VDisplayRnd + 2 * VMargin);
+
+        /* 9. Find number of lines in vertical blanking */
+        VBILines = ((float) CVT_RB_MIN_VBLANK) / HPeriod + 1;
+
+        /* 10. Check if vertical blanking is sufficient */
+        if (VBILines < (CVT_RB_VFPORCH + VSync + CVT_MIN_V_BPORCH))
+            VBILines = CVT_RB_VFPORCH + VSync + CVT_MIN_V_BPORCH;
+
+        /* 11. Find total number of lines in vertical field */
+        modeinfo.vTotal = VDisplayRnd + 2 * VMargin + Interlace + VBILines;
+
+        /* 12. Find total number of pixels in a line */
+        modeinfo.hTotal = modeinfo.width + CVT_RB_H_BLANK;
+
+        /* Fill in HSync values */
+        modeinfo.hSyncEnd = modeinfo.width + CVT_RB_H_BLANK / 2;
+        modeinfo.hSyncStart = modeinfo.hSyncEnd - CVT_RB_H_SYNC;
+
+        /* Fill in VSync values */
+        modeinfo.vSyncStart = modeinfo.height + CVT_RB_VFPORCH;
+        modeinfo.vSyncEnd = modeinfo.vSyncStart + VSync;
+    }
+
+    /* 15/13. Find pixel clock frequency (kHz for xf86) */
+    modeinfo.dotClock = modeinfo.hTotal * 1000.0 / HPeriod;
+    modeinfo.dotClock -= modeinfo.dotClock % CVT_CLOCK_STEP;
+    modeinfo.dotClock *= 1000.0;
+#if 0
+    /* 16/14. Find actual Horizontal Frequency (kHz) */
+    modeinfo.hSync = ((float) modeinfo.dotClock) / ((float) modeinfo.hTotal);
+#endif
+
+#if 0
+    /* 17/15. Find actual Field rate */
+    modeinfo.vRefresh = (1000.0 * ((float) modeinfo.dotClock)) /
+        ((float) (modeinfo.hTotal * modeinfo.vTotal));
+#endif
+
+    /* 18/16. Find actual vertical frame frequency */
+    /* ignore - just set the mode flag for interlaced */
+    if (Interlaced)
+        modeinfo.vTotal *= 2;
+
+    if (Reduced)
+        modeinfo.modeFlags |= RR_HSyncPositive | RR_VSyncNegative;
+    else
+        modeinfo.modeFlags |= RR_HSyncNegative | RR_VSyncPositive;
+
+    if (Interlaced)
+        modeinfo.modeFlags |= RR_Interlace;
+
+    snprintf(name, sizeof name, "%dx%d@%.1fHz",
+             modeinfo.width, modeinfo.height, VRefresh);
+    modeinfo.nameLength = strlen(name);
+
+    return RRModeGet(&modeinfo, name);
+}
--- /dev/null
+++ b/hw/xmir/xmir-dri2.c
@@ -0,0 +1,564 @@
+/*
+ * Copyright © 2015 Canonical Ltd
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include "glamor_priv.h"
+#include "glamor_transform.h"
+#include "xmir.h"
+
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <xf86drm.h>
+
+#define MESA_EGL_NO_X11_HEADERS
+#include <gbm.h>
+#include <epoxy/egl.h>
+#include <epoxy/gl.h>
+#include <mir_toolkit/mir_connection.h>
+/* FIXME: This should not be mandatory, especially on Android (LP: #1502794) */
+#include <mir_toolkit/mesa/platform_operation.h>
+
+/* XMir dri2 support:
+ *
+ * Pixmaps:
+ *  DRI2BufferFrontLeft: glamor pixmap
+ *  DRI2BufferFakeFrontLeft: last page flipped bo
+ *  DRI2BufferBackLeft: MirNativeBuffer
+ *
+ * Swap support:
+ *   Page will get flipped from BackLeft to FrontLeft,
+ *   but what happens is that we call mir_surface_swap_buffers
+ *
+ * There is no guarantee X and DRI2 is serialized, unless the
+ * glXWaitGL and glXWaitX calls are used. These calls are implemented
+ * by copying FakeFront to Front for glXWaitGL, and
+ * Front to FakeFront for glXwaitX
+ *
+ * TODO:
+ *  - Make xmir_dri2_copy_region do something.
+ */
+
+static char
+is_fd_render_node(int fd)
+{
+    struct stat render;
+
+    if (fstat(fd, &render))
+        return 0;
+    if (!S_ISCHR(render.st_mode))
+        return 0;
+    if (render.st_rdev & 0x80)
+        return 1;
+
+    return 0;
+}
+
+static Bool
+xmir_dri2_flink(int drm_fd, unsigned int handle, unsigned int *name)
+{
+    struct drm_gem_flink flink;
+
+    flink.handle = handle;
+    if (ioctl(drm_fd, DRM_IOCTL_GEM_FLINK, &flink) < 0)
+        return 0;
+    *name = flink.name;
+    return 1;
+}
+
+static struct xmir_window *
+xmir_window_swappable_parent(WindowPtr win)
+{
+    ScreenPtr screen = win->drawable.pScreen;
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    PixmapPtr root, pixmap;
+
+    if (xmir_screen->rootless)
+        return NULL;
+
+    root = screen->GetScreenPixmap(screen);
+    pixmap = screen->GetWindowPixmap(win);
+
+    if (root == pixmap &&
+        win->drawable.depth == pixmap->drawable.depth &&
+        win->drawable.height == pixmap->drawable.height &&
+        win->drawable.width == pixmap->drawable.width)
+        return xmir_window_get(screen->root);
+
+    return NULL;
+}
+
+static void
+xmir_dri2_reusebuffer_notify(DrawablePtr draw, DRI2BufferPtr buf)
+{
+    struct xmir_window *xmir_window;
+    struct xmir_screen *xmir_screen;
+    struct xmir_pixmap *xmir_pixmap;
+    struct gbm_bo *bo;
+
+    if (buf->attachment != DRI2BufferBackLeft || draw->type != DRAWABLE_WINDOW)
+        return;
+
+    xmir_window = xmir_window_get((WindowPtr)draw);
+    if (!xmir_window)
+        return;
+
+    xmir_screen = xmir_screen_get(draw->pScreen);
+    if (xmir_window->back_pixmap)
+        FatalError("Returned before swapping?\n");
+
+    if (xmir_window->surface) {
+        buf->driverPrivate = xmir_glamor_win_get_back(xmir_screen, xmir_window, &xmir_window->window->drawable);
+        xmir_pixmap = xmir_pixmap_get(buf->driverPrivate);
+    }
+    else {
+        struct xmir_window *xmir_window_parent = xmir_window_swappable_parent((WindowPtr)draw);
+
+        if (xmir_window_parent && xmir_window_parent->back_pixmap)
+            FatalError("Returned before swapping?!\n");
+
+        if (buf->driverPrivate) {
+            xmir_pixmap = xmir_pixmap_get(buf->driverPrivate);
+
+            if (xmir_pixmap->fake_back && !xmir_window_parent)
+                return;
+
+            draw->pScreen->DestroyPixmap(buf->driverPrivate);
+        }
+
+        buf->driverPrivate = xmir_glamor_win_get_back(xmir_screen, xmir_window_parent ?: xmir_window, &xmir_window->window->drawable);
+        xmir_pixmap = xmir_pixmap_get(buf->driverPrivate);
+    }
+    bo = xmir_pixmap->bo;
+    if (!bo)
+        FatalError("Uh oh!\n");
+
+    buf->pitch = gbm_bo_get_stride(bo);
+    xmir_dri2_flink(xmir_screen->drm_fd, gbm_bo_get_handle(bo).u32, &buf->name);
+}
+
+static void
+xmir_dri2_auth_magic_reply(MirConnection* con, MirPlatformMessage* reply, Bool* ret)
+{
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+    struct MirMesaAuthMagicResponse const* response;
+    unsigned int opcode = mir_platform_message_get_opcode(reply);
+    MirPlatformMessageData data = mir_platform_message_get_data(reply);
+
+    *ret = 0;
+    response = data.data;
+
+    if (auth_magic != opcode ||
+        data.size != sizeof response ||
+        response == NULL)
+    {
+        mir_platform_message_release(reply);
+        return;
+    }
+
+    /* status == 0 indciates success */
+    if (response->status == 0)
+        *ret = 1;
+    mir_platform_message_release(reply);
+#pragma GCC diagnostic pop
+}
+
+static Bool
+xmir_dri2_auth_magic(ScreenPtr screen, uint32_t magic)
+{
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    Bool ret = 0;
+    MirPlatformMessage *msg = NULL;
+
+    if (!is_fd_render_node(xmir_screen->drm_fd)) {
+        struct MirMesaAuthMagicRequest req = {
+            .magic = magic
+        };
+        msg = mir_platform_message_create(auth_magic);
+
+        if (msg == NULL)
+            return ret;
+
+        mir_platform_message_set_data(msg, &req, sizeof req);
+/* FIXME: This should not be mandatory, especially on Android (LP: #1502794) */
+        mir_wait_for(mir_connection_platform_operation(
+                xmir_screen->conn,
+                msg,
+                (mir_platform_operation_callback)&xmir_dri2_auth_magic_reply,
+                &ret));
+        mir_platform_message_release(msg);
+    }
+
+    return ret;
+#pragma GCC diagnostic pop
+}
+
+static DRI2BufferPtr
+xmir_dri2_create_buffer(ScreenPtr screen, DrawablePtr pDraw,
+                        unsigned int attachment, unsigned int format)
+{
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    struct xmir_pixmap *xmir_pixmap;
+    struct xmir_window *xmir_window = NULL;
+    PixmapPtr pixmap;
+    DRI2BufferPtr ret = malloc(sizeof(*ret));
+    struct gbm_bo *bo = NULL;
+    unsigned int bpp = max(format, pDraw->bitsPerPixel);
+
+    if (format && format < pDraw->bitsPerPixel && format < 24) {
+        ErrorF("Format %u must match bpp %u for window\n", format, pDraw->bitsPerPixel);
+        return NULL;
+    }
+
+    if (pDraw->type == DRAWABLE_WINDOW) {
+        struct xmir_window *xmir_window_parent;
+
+        xmir_window = xmir_window_get((WindowPtr)pDraw);
+        xmir_window_parent = xmir_window_swappable_parent((WindowPtr)pDraw);
+
+        if (xmir_window_parent)
+            xmir_window = xmir_window_parent;
+
+        pixmap = screen->GetWindowPixmap((WindowPtr)pDraw);
+    }
+    else
+        pixmap = (PixmapPtr)pDraw;
+
+    ret->attachment = attachment;
+    ret->format = format;
+    ret->driverPrivate = NULL;
+    ret->flags = 0;
+    ret->cpp = bpp / 8;
+
+    ret->name = 0;
+    ret->pitch = 0;
+
+    switch (attachment) {
+    case DRI2BufferFakeFrontLeft:
+        if (xmir_window && xmir_window->front_pixmap) {
+            xmir_pixmap = xmir_pixmap_get(xmir_window->front_pixmap);
+            bo = xmir_pixmap->bo;
+            break;
+        }
+        /* Fall-through */
+    case DRI2BufferFrontLeft:
+        xmir_pixmap = xmir_pixmap_get(pixmap);
+
+        if (!xmir_pixmap) {
+            CARD16 pitch;
+            CARD32 size;
+
+            ret->name = glamor_name_from_pixmap(pixmap, &pitch, &size);
+            ret->pitch = pitch;
+            return ret;
+        }
+        bo = xmir_pixmap->bo;
+
+        if (!bo) {
+            ErrorF("Window doesn't have a mir backing?\n");
+            break;
+        }
+        break;
+    case DRI2BufferBackLeft: {
+        ret->driverPrivate = pixmap = xmir_glamor_win_get_back(xmir_screen, xmir_window, pDraw);
+        bo = xmir_pixmap_get(pixmap)->bo;
+        break;
+    }
+    default:
+        ErrorF("Unsupported attachment %i\n", attachment);
+        return NULL;
+    }
+
+    if (!bo) {
+        ErrorF("Cannot create a %u attachment for a %u\n", attachment, pDraw->type);
+        free(ret);
+        return NULL;
+    }
+    DebugF("Allocated a %u attachment for %p/%u\n", attachment, pDraw, pDraw->type);
+    ret->pitch = gbm_bo_get_stride(bo);
+    xmir_dri2_flink(xmir_screen->drm_fd, gbm_bo_get_handle(bo).u32, &ret->name);
+    return ret;
+}
+
+static void
+xmir_dri2_destroy_buffer(ScreenPtr screen, DrawablePtr pDraw, DRI2BufferPtr buf)
+{
+    DebugF("DestroyBuffer %p/%u\n", buf, buf->attachment);
+
+    if (buf->driverPrivate)
+        screen->DestroyPixmap(buf->driverPrivate);
+    free(buf);
+}
+
+static void
+xmir_dri2_copy_region(ScreenPtr pScreen, DrawablePtr draw, RegionPtr region,
+                      DRI2BufferPtr dest, DRI2BufferPtr src)
+{
+    struct xmir_window *xmir_window = NULL;
+    ScreenPtr screen = draw->pScreen;
+
+    if (draw->type != DRAWABLE_WINDOW)
+        FatalError("Can't copy :-(\n");
+
+    if (src->attachment == DRI2BufferFakeFrontLeft && dest->attachment == DRI2BufferFrontLeft)
+        ErrorF("glXWaitGL\n");
+    else if (src->attachment == DRI2BufferFrontLeft && dest->attachment == DRI2BufferFakeFrontLeft)
+        ErrorF("glXWaitX\n");
+    else {
+        /* No swap interval, copy to front */
+        int dx, dy;
+        PixmapPtr dsrc = src->driverPrivate;
+        PixmapPtr pixmap;
+
+        if (draw->type == DRAWABLE_WINDOW) {
+            pixmap = screen->GetWindowPixmap((WindowPtr)draw);
+            xmir_window = xmir_window_get((WindowPtr)draw);
+        }
+        else
+            pixmap = (PixmapPtr)draw;
+
+        dx = draw->x - pixmap->screen_x;
+        dy = draw->y - pixmap->screen_y;
+
+        DebugF("Copying region! from %p/%u to %p/%u on %p/%u\n",
+               src, src->attachment, dest, dest->attachment, draw, draw->type);
+
+        glamor_set_destination_pixmap(pixmap);
+        xmir_glamor_copy_egl_common(&dsrc->drawable, dsrc, glamor_get_pixmap_private(dsrc),
+                                    RegionExtents(region), dsrc->drawable.width, dsrc->drawable.height,
+                                    dx, dy, xmir_window ? xmir_window->orientation : 0);
+
+        RegionTranslate(region, draw->x, draw->y);
+        DamageDamageRegion(draw, region);
+    }
+}
+
+static int
+xmir_dri2_schedule_swap(ClientPtr client, DrawablePtr draw, DRI2BufferPtr dest, DRI2BufferPtr src,
+                        CARD64 *target_msc, CARD64 divisor, CARD64 remainder,
+                        DRI2SwapEventPtr func, void *data)
+{
+    ScreenPtr screen = draw->pScreen;
+    struct xmir_pixmap *xmir_pixmap;
+    struct xmir_window *xmir_window = NULL;
+    PixmapPtr pixmap;
+    int type;
+    RegionRec region;
+    int ret = 1;
+
+    /* Noop on a glxpixmap */
+    if (draw->type == DRAWABLE_WINDOW) {
+        xmir_window = xmir_window_get((WindowPtr)draw);
+        pixmap = screen->GetWindowPixmap((WindowPtr)draw);
+
+        /* Make sure DRI2GetBuffers blocks, there is no updated buffer until the next flip */
+        DRI2SwapLimit(draw, 1);
+    }
+    else {
+        pixmap = (PixmapPtr)draw;
+        memset(target_msc, 0, sizeof(*target_msc));
+    }
+
+    xmir_pixmap = xmir_pixmap_get(pixmap);
+    if ((!xmir_pixmap || xmir_pixmap->fake_back) && (!xmir_window || !xmir_window->surface)) {
+        PixmapRegionInit(&region, src->driverPrivate);
+
+        if (draw->width == pixmap->drawable.width && draw->height == pixmap->drawable.height) {
+            glamor_pixmap_fbo *glamor_front, *glamor_back;
+            struct xmir_pixmap swap_pix;
+            struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+
+            /* Exchange pixmap data with the front glamor pixmap, and update src name/pitch */
+            DebugF("%s: Exchanging glamor pixmap from %ux%u to %ux%u\n",
+                   GetClientCmdName(client), draw->width, draw->height,
+                   pixmap->drawable.width, pixmap->drawable.height);
+            type = DRI2_EXCHANGE_COMPLETE;
+
+            src->pitch = gbm_bo_get_stride(xmir_pixmap->bo);
+            xmir_dri2_flink(xmir_screen->drm_fd, gbm_bo_get_handle(xmir_pixmap->bo).u32, &src->name);
+
+            glamor_front = glamor_pixmap_detach_fbo(glamor_get_pixmap_private(pixmap));
+            glamor_back = glamor_pixmap_detach_fbo(glamor_get_pixmap_private(src->driverPrivate));
+
+            glamor_pixmap_attach_fbo(pixmap, glamor_back);
+            glamor_pixmap_attach_fbo(src->driverPrivate, glamor_front);
+
+            swap_pix = *xmir_pixmap;
+            *xmir_pixmap = *xmir_pixmap_get(src->driverPrivate);
+            *xmir_pixmap_get(src->driverPrivate) = swap_pix;
+        }
+        else {
+            PixmapPtr dsrc = src->driverPrivate;
+            int dx = draw->x - pixmap->screen_x, dy = draw->y - pixmap->screen_y;
+
+            type = DRI2_BLIT_COMPLETE;
+            glamor_set_destination_pixmap(pixmap);
+
+            DebugF("%s: Blitting into glamor pixmap from src %u,%u %ux%u@%u draw %u,%u %ux%u@%u to %u,%u %ux%u@%u\n",
+                   GetClientCmdName(client), dsrc->drawable.x, dsrc->drawable.y,
+                   dsrc->drawable.width, dsrc->drawable.height, dsrc->drawable.depth,
+                   draw->x, draw->y, draw->width, draw->height, draw->depth,
+                   pixmap->drawable.x, pixmap->drawable.y,
+                   pixmap->drawable.width, pixmap->drawable.height, pixmap->drawable.depth);
+
+            xmir_glamor_copy_egl_common(&dsrc->drawable, dsrc, glamor_get_pixmap_private(dsrc),
+                                        RegionExtents(&region), dsrc->drawable.width, dsrc->drawable.height,
+                                        dx, dy, xmir_window ? xmir_window->orientation : 0);
+        }
+        RegionTranslate(&region, draw->x, draw->y);
+    }
+    else {
+        if (!xmir_window->surface)
+            xmir_window = xmir_window_get(screen->root);
+
+        if (xmir_window->back_pixmap)
+            FatalError("Swapping twice?\n");
+
+        /* Fastest case, no pixels need to be copied! */
+        type = DRI2_FLIP_COMPLETE;
+
+        xmir_window->back_pixmap = src->driverPrivate;
+        src->driverPrivate = NULL;
+
+        DebugF("%s: Queuing flip on %p\n", GetClientCmdName(client), draw);
+    }
+
+    if (!xmir_window) {
+        DebugF("%s: No window, completing immediately\n", GetClientCmdName(client));
+
+        DRI2SwapComplete(client, draw, 0, 0, 0, type, func, data);
+        goto err;
+    }
+
+    xmir_window->flip = (typeof(xmir_window->flip)){ client, type, draw, func, data, xmir_window->flip.entry };
+
+    if (!xmir_window->surface) {
+        struct xorg_list *entry = &xmir_window->flip.entry;
+
+        if (!xorg_list_is_empty(&xmir_window->flip.entry))
+            FatalError("%s: Flipping child window repeatedly!\n", GetClientCmdName(client));
+
+        while (!xmir_window->surface) {
+           WindowPtr window = xmir_window->window->parent;
+           if (!window) {
+               ErrorF("%s: Could not find mir surface for swapping!\n", GetClientCmdName(client));
+               ret = 0;
+               goto err;
+           }
+
+           xmir_window = xmir_window_get(window);
+        }
+        xorg_list_add(entry, &xmir_window->flip.entry);
+    }
+
+    /* Must report damage after adding flip entry, in case flip completes immediately */
+    if (type != DRI2_FLIP_COMPLETE) {
+        DamageDamageRegion(draw, &region);
+        RegionUninit(&region);
+    }
+    else
+        DamageReportDamage(xmir_window->damage, &xmir_window->region);
+
+    return 1;
+
+err:
+    RegionUninit(&region);
+    DRI2SwapLimit(draw, 2);
+    return ret;
+}
+
+static Bool
+xmir_dri2_swap_limit_validate(DrawablePtr draw, int swap_limit)
+{
+	if ((swap_limit < 1) || (swap_limit > 2))
+		return FALSE;
+
+	return TRUE;
+}
+
+static int xmir_dri_get_msc(DrawablePtr draw, CARD64 *ust, CARD64 *msc)
+{
+    /* TODO: Implement this properly after Mir implements it. */
+    const uint64_t now_us = GetTimeInMicros();
+    const uint64_t fake_frame_rate_hz = 60;
+    const uint64_t fake_frame_time_us = 1000000 / fake_frame_rate_hz;
+    const uint64_t fake_msc = now_us / fake_frame_time_us;
+    const uint64_t fake_ust = fake_msc * fake_frame_time_us;
+    if (ust)
+        *(uint64_t*)ust = fake_ust;
+    if (msc)
+        *(uint64_t*)msc = fake_msc;
+    return Success;
+}
+
+Bool
+xmir_dri2_screen_init(struct xmir_screen *xmir_screen)
+{
+    const char *driverNames[2];
+    Bool ret;
+    drmVersion *vers = drmGetVersion(xmir_screen->drm_fd);
+    const char *driver;
+
+    if (!vers)
+        return FALSE;
+
+    xmir_screen->dri2.version = 9;
+
+    /* Abuse the megablob ability to load all needed drivers */
+    if (!strcmp(vers->name, "radeon"))
+        driver = "r600";
+    else
+        driver = vers->name;
+
+    driverNames[0] = driverNames[1] = xmir_screen->driver_name = strdup(driver);
+    drmFreeVersion(vers);
+
+    /* As far as I can tell, only legacy AuthMagic has a use for the fd.. oh well */
+    xmir_screen->dri2.fd = xmir_screen->drm_fd;
+    xmir_screen->dri2.driverName = driverNames[0];
+    xmir_screen->dri2.deviceName = xmir_screen->device_name;
+
+    xmir_screen->dri2.numDrivers = 2;
+    xmir_screen->dri2.driverNames = driverNames;
+
+    /* 6 */
+    xmir_screen->dri2.ReuseBufferNotify = xmir_dri2_reusebuffer_notify;
+    xmir_screen->dri2.SwapLimitValidate = xmir_dri2_swap_limit_validate;
+    xmir_screen->dri2.ScheduleSwap = xmir_dri2_schedule_swap;
+    xmir_screen->dri2.GetMSC = xmir_dri_get_msc;
+
+    /* 8 */
+    xmir_screen->dri2.AuthMagic2 = xmir_dri2_auth_magic;
+
+    /* 9 */
+    xmir_screen->dri2.CreateBuffer2 = xmir_dri2_create_buffer;
+    xmir_screen->dri2.DestroyBuffer2 = xmir_dri2_destroy_buffer;
+    xmir_screen->dri2.CopyRegion2 = xmir_dri2_copy_region;
+
+    ret = DRI2ScreenInit(xmir_screen->screen, &xmir_screen->dri2);
+    return ret;
+}
--- /dev/null
+++ b/hw/xmir/xmir-glamor.c
@@ -0,0 +1,1156 @@
+/*
+ * Copyright © 2015-2017 Canonical Ltd
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+/* include glamor_priv instead of the public headers to get the prototype for glamor_copy_n_to_n */
+#include "glamor_priv.h"
+#include "xmir.h"
+
+#include <mir_toolkit/mir_surface.h>
+
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <xf86drm.h>
+
+#define MESA_EGL_NO_X11_HEADERS
+#include <gbm.h>
+#include <epoxy/egl.h>
+#include <epoxy/gl.h>
+#include <pthread.h>
+#include <mir_toolkit/mir_connection.h>
+#include <mir_toolkit/mir_platform_message.h>
+#include <mir_toolkit/mesa/platform_operation.h>
+
+static void
+xmir_glamor_egl_make_current(struct glamor_context *glamor_ctx)
+{
+    if (!glamor_ctx->drawable)
+        eglMakeCurrent(glamor_ctx->display, EGL_NO_SURFACE,
+                       EGL_NO_SURFACE, EGL_NO_CONTEXT);
+
+    if (!eglMakeCurrent(glamor_ctx->display,
+                        glamor_ctx->drawable, glamor_ctx->drawable,
+                        glamor_ctx->ctx))
+        FatalError("Failed to make EGL context current\n");
+}
+
+void
+glamor_egl_screen_init(ScreenPtr screen, struct glamor_context *glamor_ctx)
+{
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+
+    glamor_ctx->ctx = xmir_screen->egl_context;
+    glamor_ctx->display = xmir_screen->egl_display;
+
+    glamor_ctx->make_current = xmir_glamor_egl_make_current;
+    glamor_ctx->drawable = xmir_screen->egl_surface;
+
+    xmir_screen->glamor_ctx = glamor_ctx;
+}
+
+static PixmapPtr
+xmir_glamor_win_reuse_pixmap(struct xmir_screen *xmir_screen, struct xmir_window *xmir_win, DrawablePtr draw)
+{
+    struct xmir_pixmap *xmir_pixmap;
+    PixmapPtr ret;
+
+    if (!xmir_win->reuse_pixmap)
+        return NULL;
+
+    ret = xmir_win->reuse_pixmap;
+    xmir_win->reuse_pixmap = NULL;
+
+    xmir_pixmap = xmir_pixmap_get(ret);
+    eglDestroyImageKHR(xmir_screen->egl_display, xmir_pixmap->image);
+    gbm_bo_destroy(xmir_pixmap->bo);
+    memset(xmir_pixmap, 0, sizeof(*xmir_pixmap));
+    return ret;
+}
+
+PixmapPtr
+xmir_glamor_win_get_back(struct xmir_screen *xmir_screen, struct xmir_window *xmir_win, DrawablePtr draw)
+{
+    ScreenPtr screen = xmir_screen->screen;
+    struct xmir_pixmap *xmir_pixmap;
+    PixmapPtr ret = NULL;
+    struct gbm_bo *bo;
+    unsigned int tex;
+
+    if (xmir_win) {
+        if (xmir_win->back_pixmap) {
+            ErrorF("Uh oh!\n");
+            return xmir_win->back_pixmap;
+        }
+
+        ret = xmir_glamor_win_reuse_pixmap(xmir_screen, xmir_win, draw);
+    }
+
+    if (!ret)
+        ret = screen->CreatePixmap(screen,
+                                   draw->width, draw->height, draw->depth,
+                                   XMIR_CREATE_PIXMAP_USAGE_FLIP);
+
+    xmir_pixmap = xmir_pixmap_get(ret);
+
+    if (xmir_win && xmir_win->surface) {
+        MirNativeBuffer *buffer;
+        struct gbm_import_fd_data gbm_data;
+
+        mir_buffer_stream_get_current_buffer(mir_window_get_buffer_stream(xmir_win->surface), &buffer);
+
+        gbm_data.fd = buffer->fd[0];
+        gbm_data.width = buffer->width;
+        gbm_data.height = buffer->height;
+        gbm_data.stride = buffer->stride;
+        gbm_data.format = GBM_FORMAT_ARGB8888; /* TODO: detect this properly */
+
+        bo = gbm_bo_import(xmir_screen->gbm, GBM_BO_IMPORT_FD, &gbm_data, GBM_BO_USE_RENDERING);
+        xmir_pixmap->fake_back = false;
+    }
+    else {
+        bo = gbm_bo_create(xmir_screen->gbm, draw->width, draw->height,
+                           GBM_FORMAT_ARGB8888,
+                           GBM_BO_USE_RENDERING);
+        xmir_pixmap->fake_back = true;
+    }
+    if (!bo)
+        FatalError("Failed to allocate bo\n");
+
+    ret->devKind = gbm_bo_get_stride(bo);
+    xmir_pixmap->bo = bo;
+    xmir_pixmap->image = eglCreateImageKHR(xmir_screen->egl_display, xmir_screen->egl_context, EGL_NATIVE_PIXMAP_KHR, bo, NULL);
+
+    glGenTextures(1, &tex);
+    glBindTexture(GL_TEXTURE_2D, tex);
+    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, xmir_pixmap->image);
+    glBindTexture(GL_TEXTURE_2D, 0);
+    glamor_set_pixmap_texture(ret, tex);
+
+    return ret;
+}
+
+static void
+complete_flips(struct xmir_window *xmir_win)
+{
+    if (xmir_win->flip.client) {
+        DebugF("Flipping on %p\n", xmir_win->window);
+
+        DRI2SwapComplete(xmir_win->flip.client, xmir_win->flip.draw, 0, 0, 0, xmir_win->flip.type, xmir_win->flip.func, xmir_win->flip.data);
+        DRI2SwapLimit(xmir_win->flip.draw, 2);
+        xmir_win->flip.client = NULL;
+    }
+
+    if (!xmir_win->surface) {
+        xorg_list_del(&xmir_win->flip.entry);
+        return;
+    }
+
+    while (!xorg_list_is_empty(&xmir_win->flip.entry)) {
+        struct xmir_window *xwin = xorg_list_first_entry(&xmir_win->flip.entry, struct xmir_window, flip.entry);
+        struct xmir_flip *flip = &xwin->flip;
+
+        DebugF("Flipping child %p\n", xwin->window);
+
+        DRI2SwapComplete(flip->client, flip->draw, 0, 0, 0, flip->type, flip->func, flip->data);
+        DRI2SwapLimit(flip->draw, 2);
+        flip->client = NULL;
+        xorg_list_del(&flip->entry);
+    }
+}
+
+static void
+xmir_glamor_copy_egl_tex(int fbo, DrawablePtr src, PixmapPtr src_pixmap, glamor_pixmap_private *src_pixmap_priv, BoxPtr box, EGLint width, EGLint height, int dstx, int dsty, int orientation)
+{
+    glamor_screen_private *glamor_priv = glamor_get_screen_private(src->pScreen);
+    struct xmir_screen *xmir_screen = xmir_screen_get(src->pScreen);
+    float vertices[8], texcoords[8];
+    GLfloat src_xscale, src_yscale, dst_xscale = 1.0 / width, dst_yscale = 1.0 / height;
+    int dx, dy;
+
+    bool reflect_x = false;
+    bool reflect_y = false;
+    bool swap_xy = false;
+    BoxRec dbox;
+
+    /* reflection test parameters */
+    bool magic_x_invert = false, magic_y_invert = false;
+
+    if (xmir_screen->doubled) {
+        dst_xscale /= (1. + xmir_screen->doubled);
+        dst_yscale /= (1. + xmir_screen->doubled);
+    }
+
+    if (magic_x_invert)
+        reflect_x = !reflect_x;
+
+    if (magic_y_invert)
+        reflect_y = !reflect_y;
+
+    switch (orientation) {
+    case 90:
+        reflect_y = !reflect_y; reflect_x = !reflect_x; swap_xy = true; break;
+    case 180:
+        reflect_x = !reflect_x; reflect_y = !reflect_y; break;
+    case 270:
+        swap_xy = true; break;
+    }
+
+    glamor_get_drawable_deltas(src, src_pixmap, &dx, &dy);
+
+    pixmap_priv_get_scale(src_pixmap_priv, &src_xscale, &src_yscale);
+
+    if (src_pixmap_priv->gl_fbo == GLAMOR_FBO_UNATTACHED)
+        FatalError("aeiou\n");
+
+    glViewport(dx, dy, width + dx, height + dy);
+
+    glVertexAttribPointer(GLAMOR_VERTEX_POS, 2, GL_FLOAT,
+                          GL_FALSE, 2 * sizeof(float), vertices);
+    glEnableVertexAttribArray(GLAMOR_VERTEX_POS);
+
+    if (!fbo) {
+       glActiveTexture(GL_TEXTURE0);
+       glBindTexture(GL_TEXTURE_2D, src_pixmap_priv->fbo->tex);
+
+        if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP) {
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
+        }
+    }
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+    glVertexAttribPointer(GLAMOR_VERTEX_SOURCE, 2, GL_FLOAT, GL_FALSE,
+                          2 * sizeof(float), texcoords);
+    glEnableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
+
+    if (!swap_xy) {
+        float _tx1, _tx2, _ty1, _ty2;
+
+        if (reflect_x) {
+            dbox.x1 = box->x2 + dstx;
+            dbox.x2 = box->x1 + dstx;
+        }
+        else {
+            dbox.x1 = box->x1 + dstx;
+            dbox.x2 = box->x2 + dstx;
+        }
+
+        if (reflect_y) {
+            dbox.y1 = box->y2 + dsty;
+            dbox.y2 = box->y1 + dsty;
+        }
+        else {
+            dbox.y1 = box->y1 + dsty;
+            dbox.y2 = box->y2 + dsty;
+        }
+
+        _tx1 = v_from_x_coord_x(dst_xscale, dbox.x1);
+        _tx2 = v_from_x_coord_x(dst_xscale, dbox.x2);
+
+        _ty1 = v_from_x_coord_y(dst_yscale, dbox.y1);
+        _ty2 = v_from_x_coord_y(dst_yscale, dbox.y2);
+
+        /* upper left */
+        vertices[0] = _tx1;
+        vertices[1] = _ty1;
+
+        /* upper right */
+        vertices[2] = _tx2;
+        vertices[3] = _ty1;
+
+        /* bottom right */
+        vertices[4] = _tx2;
+        vertices[5] = _ty2;
+
+        /* bottom left */
+        vertices[6] = _tx1;
+        vertices[7] = _ty2;
+    }
+    else {
+        float _tx1, _tx2, _ty1, _ty2;
+
+        if (reflect_x) {
+            dbox.y1 = box->x2 + dstx;
+            dbox.y2 = box->x1 + dstx;
+        }
+        else {
+            dbox.y1 = box->x1 + dstx;
+            dbox.y2 = box->x2 + dstx;
+        }
+
+        if (reflect_y) {
+            dbox.x1 = box->y2 + dsty;
+            dbox.x2 = box->y1 + dsty;
+        }
+        else {
+            dbox.x1 = box->y1 + dsty;
+            dbox.x2 = box->y2 + dsty;
+        }
+
+        _tx1 = v_from_x_coord_x(dst_xscale, dbox.x1);
+        _tx2 = v_from_x_coord_x(dst_xscale, dbox.x2);
+
+        _ty1 = v_from_x_coord_y(dst_yscale, dbox.y1);
+        _ty2 = v_from_x_coord_y(dst_yscale, dbox.y2);
+
+        /* upper right */
+        vertices[0] = _tx2;
+        vertices[1] = _ty1;
+
+        /* bottom right */
+        vertices[2] = _tx2;
+        vertices[3] = _ty2;
+
+        /* bottom left */
+        vertices[4] = _tx1;
+        vertices[5] = _ty2;
+
+        /* upper left */
+        vertices[6] = _tx1;
+        vertices[7] = _ty1;
+    }
+
+    if (orientation)
+        DebugF("(%u,%u)(%u,%u) -> (%u,%u)(%u,%u) with %u orientation\n",
+               box->x1 + dx, box->y1 + dy, box->x2 + dx, box->y2 + dy,
+               dbox.x1, dbox.y1, dbox.x2, dbox.y2, orientation);
+
+    glamor_set_normalize_tcoords_ext(src_pixmap_priv,
+                                 src_xscale, src_yscale,
+                                 box->x1 + dx, box->y1 + dy,
+                                 box->x2 + dx, box->y2 + dy,
+                                 texcoords, 2);
+    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+
+    glDisableVertexAttribArray(GLAMOR_VERTEX_POS);
+    glDisableVertexAttribArray(GLAMOR_VERTEX_SOURCE);
+}
+
+void
+xmir_glamor_copy_egl_common(DrawablePtr src, PixmapPtr src_pixmap,
+                            glamor_pixmap_private *src_pixmap_priv,
+                            BoxPtr ext, int width, int height, int dx, int dy,
+                            int orientation)
+{
+    struct xmir_screen *xmir_screen = xmir_screen_get(src->pScreen);
+    DebugF("Box: (%i,%i)->(%i,%i)\n", ext->x1, ext->y1, ext->x2, ext->y2);
+
+    if (xmir_screen->glamor_has_GL_EXT_framebuffer_blit &&
+        !xmir_screen->doubled && !orientation) {
+        glBindFramebufferEXT(GL_READ_FRAMEBUFFER_EXT, src_pixmap_priv->fbo->fb);
+
+        glBlitFramebuffer(ext->x1, ext->y2, ext->x2, ext->y1,
+                          ext->x1 + dx, ext->y2 + dy, ext->x2 + dx, ext->y1 + dy,
+                          GL_COLOR_BUFFER_BIT, GL_LINEAR);
+    }
+    else
+        xmir_glamor_copy_egl_tex(0, src, src_pixmap, src_pixmap_priv, ext, width, height, dx, dy, orientation);
+}
+
+static void
+xmir_glamor_copy_gbm(struct xmir_screen *xmir_screen, struct xmir_window *xmir_win, RegionPtr dirty)
+{
+    ScreenPtr screen = xmir_screen->screen;
+    WindowPtr window = xmir_win->window;
+
+    if (lastGLContext != xmir_screen->egl_context) {
+        lastGLContext = xmir_screen->egl_context;
+        xmir_glamor_egl_make_current(xmir_screen->glamor_ctx);
+    }
+
+    complete_flips(xmir_win);
+
+    if (xmir_win->front_pixmap) {
+        if (xmir_win->reuse_pixmap) {
+            ErrorF("Got too many buffers!\n");
+            screen->DestroyPixmap(xmir_win->reuse_pixmap);
+        }
+
+        xmir_win->reuse_pixmap = xmir_win->front_pixmap;
+    }
+
+    if (!xmir_win->back_pixmap) {
+        PixmapPtr back = xmir_glamor_win_get_back(xmir_screen, xmir_win, &window->drawable);
+        PixmapPtr from = screen->GetWindowPixmap(window);
+        glamor_pixmap_private *pixmap_priv = glamor_get_pixmap_private(back);
+
+        glBindFramebuffer(GL_FRAMEBUFFER, pixmap_priv->fbo->fb);
+        xmir_glamor_copy_egl_common(&window->drawable, from, glamor_get_pixmap_private(from),
+                                    RegionExtents(dirty),
+                                    back->drawable.width, back->drawable.height, 0, 0, xmir_win->orientation);
+
+        xmir_win->front_pixmap = back;
+        glBindFramebuffer(GL_FRAMEBUFFER, 0);
+    }
+    else {
+        xmir_win->front_pixmap = xmir_win->back_pixmap;
+        xmir_win->back_pixmap = NULL;
+    }
+}
+
+static GLint xmir_glamor_passthrough_prog(ScreenPtr screen)
+{
+    const char *vs_source =
+        "attribute vec4 v_position;\n"
+        "attribute vec4 v_texcoord0;\n"
+        "varying vec2 source_texture;\n"
+        "void main()\n"
+        "{\n"
+        "	gl_Position = v_position;\n"
+        "	source_texture = v_texcoord0.xy;\n"
+        "}\n";
+
+    const char *fs_source =
+        GLAMOR_DEFAULT_PRECISION
+        "varying vec2 source_texture;\n"
+        "uniform sampler2D sampler;\n"
+        "void main()\n"
+        "{\n"
+        "    gl_FragColor = texture2D(sampler, source_texture);\n"
+        "}\n";
+
+
+    GLint fs_prog, vs_prog;
+    GLint sampler_uniform_location;
+    GLint passthrough_prog = glCreateProgram();
+
+    vs_prog = glamor_compile_glsl_prog(GL_VERTEX_SHADER, vs_source);
+
+    fs_prog = glamor_compile_glsl_prog(GL_FRAGMENT_SHADER, fs_source);
+
+    glAttachShader(passthrough_prog, vs_prog);
+    glAttachShader(passthrough_prog, fs_prog);
+
+    glBindAttribLocation(passthrough_prog,
+                         GLAMOR_VERTEX_POS, "v_position");
+    glBindAttribLocation(passthrough_prog,
+                         GLAMOR_VERTEX_SOURCE, "v_texcoord0");
+    glamor_link_glsl_prog(screen, passthrough_prog,
+                          "finish swap through blit");
+
+    sampler_uniform_location =
+        glGetUniformLocation(passthrough_prog, "sampler");
+    glUseProgram(passthrough_prog);
+    glUniform1i(sampler_uniform_location, 0);
+
+    return passthrough_prog;
+}
+
+static void *
+xmir_glamor_flip(void *data)
+{
+    struct xmir_screen *xmir_screen = data;
+    struct glamor_screen_private *glamor_priv =
+        glamor_get_screen_private(xmir_screen->screen);
+    int passthrough_prog;
+    GLuint tex;
+
+    pthread_mutex_lock(&xmir_screen->mutex);
+    if (xmir_screen->alive < 0)
+        pthread_exit(NULL);
+
+    if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP)
+        eglBindAPI(EGL_OPENGL_API);
+
+    xmir_screen->alive = 1;
+    if (!eglMakeCurrent(xmir_screen->egl_display, xmir_screen->swap_surface, xmir_screen->swap_surface, xmir_screen->swap_context))
+        ErrorF("eglMakeCurrent failed: %x\n", eglGetError());
+    passthrough_prog = xmir_glamor_passthrough_prog(xmir_screen->screen);
+
+    glGenTextures(1, &tex);
+    glBindTexture(GL_TEXTURE_2D, tex);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+
+    if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP) {
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
+        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
+    }
+
+    while (xmir_screen->alive >= 0) {
+        if (xorg_list_is_empty(&xmir_screen->swap_list))
+            pthread_cond_wait(&xmir_screen->cond, &xmir_screen->mutex);
+
+        while (!xorg_list_is_empty(&xmir_screen->swap_list)) {
+            struct xmir_window *xmir_win;
+            Bool ret;
+            EGLint val, width, height;
+            PixmapPtr src_pixmap;
+
+            xmir_win = xorg_list_first_entry(&xmir_screen->swap_list, struct xmir_window, flip.entry);
+
+            DebugF("Handling %p\n", xmir_win);
+            if (xmir_win->flip.data) {
+                val = eglClientWaitSync(xmir_screen->egl_display, xmir_win->flip.data, 0, 1000000000);
+                if (val != EGL_CONDITION_SATISFIED_KHR)
+                    ErrorF("eglClientWaitSync failed: %x/%x\n", val, eglGetError());
+                eglDestroySync(xmir_screen->egl_display, xmir_win->flip.data);
+            }
+
+            ret = eglMakeCurrent(xmir_screen->egl_display, xmir_win->egl_surface, xmir_win->egl_surface, xmir_screen->swap_context);
+            if (!ret)
+                ErrorF("eglMakeCurrent failed: %x\n", eglGetError());
+
+            glClearColor(0., 1., 0., 1.);
+            glClear(GL_COLOR_BUFFER_BIT);
+
+            glEGLImageTargetTexture2DOES(GL_TEXTURE_2D,
+                                         (GLeglImageOES)xmir_win->image);
+
+            eglQuerySurface(xmir_screen->egl_display, xmir_win->egl_surface, EGL_HEIGHT, &height);
+            eglQuerySurface(xmir_screen->egl_display, xmir_win->egl_surface, EGL_WIDTH, &width);
+            src_pixmap = xmir_screen->screen->GetWindowPixmap(xmir_win->window);
+            xmir_glamor_copy_egl_tex(1, &xmir_win->window->drawable, src_pixmap, glamor_get_pixmap_private(src_pixmap), RegionExtents(&xmir_win->region), width, height, 0, 0, xmir_win->orientation);
+
+            ret = eglSwapBuffers(xmir_screen->egl_display, xmir_win->egl_surface);
+            if (!ret)
+                ErrorF("eglSwapBuffers failed: %x\n", eglGetError());
+            ret = eglMakeCurrent(xmir_screen->egl_display, xmir_screen->swap_surface, xmir_screen->swap_surface, xmir_screen->swap_context);
+            if (!ret)
+                ErrorF("eglMakeCurrent failed: %x\n", eglGetError());
+
+            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 0, 0, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+            xorg_list_del(&xmir_win->flip.entry);
+            xmir_post_to_eventloop(xmir_handle_buffer_available, xmir_screen,
+                                   xmir_win, 0);
+        }
+    }
+    glDeleteTextures(1, &tex);
+    glDeleteProgram(passthrough_prog);
+    if (!eglMakeCurrent(xmir_screen->egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT))
+        ErrorF("eglMakeCurrent failed: %x\n", eglGetError());
+    pthread_mutex_unlock(&xmir_screen->mutex);
+
+    return NULL;
+}
+
+static void
+xmir_glamor_copy_egl_direct(struct xmir_screen *xmir_screen, struct xmir_window *xmir_win, RegionPtr dirty)
+{
+    ScreenPtr screen = xmir_screen->screen;
+    WindowPtr window = xmir_win->window;
+    PixmapPtr src_pixmap = screen->GetWindowPixmap(window);
+    glamor_pixmap_private *src_pixmap_priv = glamor_get_pixmap_private(src_pixmap);
+
+    BoxPtr ext = RegionExtents(dirty);
+    EGLint width, height;
+
+    lastGLContext = xmir_screen->egl_context;
+
+    if (!eglMakeCurrent(xmir_screen->egl_display, xmir_win->egl_surface, xmir_win->egl_surface, xmir_screen->egl_context))
+        ErrorF("Failed to make current!\n");
+
+    if (epoxy_is_desktop_gl())
+        glDrawBuffer(GL_BACK);
+
+    glBindFramebuffer(GL_FRAMEBUFFER, 0);
+
+    eglQuerySurface(xmir_screen->egl_display, xmir_win->egl_surface, EGL_HEIGHT, &height);
+    eglQuerySurface(xmir_screen->egl_display, xmir_win->egl_surface, EGL_WIDTH, &width);
+    xmir_glamor_copy_egl_common(&window->drawable, src_pixmap, src_pixmap_priv, ext, width, height, 0, 0, xmir_win->orientation);
+    eglSwapBuffers(xmir_screen->egl_display, xmir_win->egl_surface);
+}
+
+static void
+xmir_glamor_copy_egl_queue(struct xmir_screen *xmir_screen, struct xmir_window *xmir_win, RegionPtr dirty)
+{
+    void *sync_fd = NULL;
+    ScreenPtr screen = xmir_screen->screen;
+    WindowPtr window = xmir_win->window;
+    PixmapPtr src_pixmap = screen->GetWindowPixmap(window);
+    glamor_pixmap_private *src_pixmap_priv = glamor_get_pixmap_private(src_pixmap);
+
+    if (lastGLContext != xmir_screen->egl_context) {
+        lastGLContext = xmir_screen->egl_context;
+        xmir_glamor_egl_make_current(xmir_screen->glamor_ctx);
+    }
+
+    if (!xmir_win->image) {
+        EGLint attribs[] = {
+            EGL_IMAGE_PRESERVED_KHR, EGL_TRUE,
+            EGL_GL_TEXTURE_LEVEL_KHR, 0,
+            EGL_NONE
+        };
+
+        /* Keep the image around until resizing is done, and mark image as
+         * external so it won't re-enter the FBO cache. This texture has to
+         * be deleted to allow followup eglCreateImageKHR's to succeed after
+         * rotating back and forth.
+         */
+        glamor_set_pixmap_type(src_pixmap, GLAMOR_TEXTURE_DRM);
+
+        xmir_win->image = eglCreateImageKHR(xmir_screen->egl_display, xmir_screen->egl_context, EGL_GL_TEXTURE_2D_KHR, (EGLClientBuffer)(intptr_t)src_pixmap_priv->fbo->tex, attribs);
+        if (!xmir_win->image) {
+            GLint error;
+            ErrorF("eglCreateImageKHR failed with %x\n", eglGetError());
+
+            while ((error = eglGetError()) != EGL_SUCCESS)
+                ErrorF("Error stack: %x\n", error);
+
+            xmir_glamor_copy_egl_direct(xmir_screen, xmir_win, dirty);
+            return;
+        }
+    }
+
+    if (epoxy_has_gl_extension("GL_OES_EGL_sync"))
+        sync_fd = eglCreateSyncKHR(xmir_screen->egl_display, EGL_SYNC_FENCE_KHR, NULL);
+
+    /* Flush work, and the sync_fd if created */
+    glFlush();
+
+    DebugF("Queueing on %p with %p\n", xmir_win, xmir_win->image);
+
+    pthread_mutex_lock(&xmir_screen->mutex);
+    xmir_win->flip.data = sync_fd;
+    xorg_list_add(&xmir_win->flip.entry, &xmir_screen->swap_list);
+    pthread_mutex_unlock(&xmir_screen->mutex);
+
+    pthread_cond_signal(&xmir_screen->cond);
+
+    xmir_win->has_free_buffer = FALSE;
+}
+
+void
+xmir_glamor_copy(struct xmir_screen *xmir_screen, struct xmir_window *xmir_win, RegionPtr dirty)
+{
+    if (xmir_screen->gbm)
+        xmir_glamor_copy_gbm(xmir_screen, xmir_win, dirty);
+    else {
+        xorg_list_del(&xmir_win->link_damage);
+
+        if (!xmir_screen->swap_context)
+            xmir_glamor_copy_egl_direct(xmir_screen, xmir_win, dirty);
+        else
+            xmir_glamor_copy_egl_queue(xmir_screen, xmir_win, dirty);
+
+        RegionEmpty(dirty);
+    }
+}
+
+static EGLConfig
+xmir_glamor_get_egl_config(struct xmir_screen *xmir_screen)
+{
+    EGLConfig eglconfig;
+    EGLint neglconfigs;
+
+    EGLint attribs[] = {
+        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+        EGL_COLOR_BUFFER_TYPE, EGL_RGB_BUFFER,
+        EGL_BUFFER_SIZE, 32,
+        EGL_NONE
+    };
+
+    if (!epoxy_has_egl_extension(xmir_screen->egl_display, "EGL_KHR_surfaceless_context"))
+        attribs[1] |= EGL_PBUFFER_BIT;
+
+    if (!eglChooseConfig(xmir_screen->egl_display, attribs, &eglconfig, 1, &neglconfigs) ||
+        !neglconfigs)
+        FatalError("Could not create a compatible config!\n");
+
+    return eglconfig;
+}
+
+void
+xmir_glamor_realize_window(struct xmir_screen *xmir_screen, struct xmir_window *xmir_window, WindowPtr window)
+{
+    EGLConfig eglconfig = xmir_glamor_get_egl_config(xmir_screen);
+    MirEGLNativeWindowType egl_win;
+
+    if (xmir_screen->gbm)
+        return;
+
+    egl_win = mir_buffer_stream_get_egl_native_window(mir_window_get_buffer_stream(xmir_window->surface));
+
+    xmir_window->egl_surface = eglCreateWindowSurface(xmir_screen->egl_display, eglconfig, (EGLNativeWindowType)egl_win, NULL);
+}
+
+void
+xmir_glamor_unrealize_window(struct xmir_screen *xmir_screen, struct xmir_window *xmir_window, WindowPtr window)
+{
+    ScreenPtr screen = xmir_screen->screen;
+
+    if (xmir_window->egl_surface) {
+        lastGLContext = NULL;
+        if (!eglMakeCurrent(xmir_screen->egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT))
+            ErrorF("eglMakeCurrent failed: %x\n", eglGetError());
+
+        if (!xmir_window->has_free_buffer) {
+            Bool flush = TRUE;
+
+            pthread_mutex_lock(&xmir_screen->mutex);
+            if (!xorg_list_is_empty(&xmir_window->flip.entry)) {
+                if (xmir_window->flip.data)
+                    eglDestroySync(xmir_screen->egl_display, xmir_window->flip.data);
+                xorg_list_del(&xmir_window->flip.entry);
+                flush = FALSE;
+            }
+            pthread_mutex_unlock(&xmir_screen->mutex);
+
+            if (flush)
+                xmir_process_from_eventloop();
+        }
+
+        if (xmir_window->image)
+            eglDestroyImageKHR(xmir_screen->egl_display, xmir_window->image);
+
+        eglDestroySurface(xmir_screen->egl_display, xmir_window->egl_surface);
+    }
+
+    complete_flips(xmir_window);
+
+    if (xmir_window->reuse_pixmap) {
+        screen->DestroyPixmap(xmir_window->reuse_pixmap);
+        xmir_window->reuse_pixmap = NULL;
+    }
+
+    if (xmir_window->front_pixmap) {
+        screen->DestroyPixmap(xmir_window->front_pixmap);
+        xmir_window->front_pixmap = NULL;
+    }
+
+    if (xmir_window->back_pixmap) {
+        screen->DestroyPixmap(xmir_window->back_pixmap);
+        xmir_window->back_pixmap = NULL;
+    }
+}
+
+static void
+xmir_drm_set_gbm_device_response(MirConnection *con, MirPlatformMessage* reply, void* context)
+{
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+    mir_platform_message_release(reply);
+#pragma GCC diagnostic pop
+}
+
+static Bool
+xmir_drm_init_egl(struct xmir_screen *xmir_screen)
+{
+    EGLint major, minor;
+    const char *version;
+    EGLConfig egl_config;
+
+    EGLint gles2_attribs[] = {
+        EGL_CONTEXT_CLIENT_VERSION, 2,
+        EGL_CONTEXT_FLAGS_KHR, 0,
+        EGL_NONE
+    };
+
+    EGLint pbuffer_attribs[] = {
+        EGL_HEIGHT, 1,
+        EGL_WIDTH, 1,
+        EGL_NONE
+    };
+
+
+    if (xmir_screen->drm_fd > 0) {
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+        struct MirMesaSetGBMDeviceRequest req = {
+            .device = gbm_create_device(xmir_screen->drm_fd)
+        };
+        MirPlatformMessage* msg = mir_platform_message_create(set_gbm_device);
+
+        xmir_screen->gbm = req.device;
+        if (xmir_screen->gbm == NULL) {
+            ErrorF("couldn't get display device\n");
+            mir_platform_message_release(msg);
+            return FALSE;
+        }
+
+        mir_platform_message_set_data(msg, &req, sizeof req);
+
+        mir_wait_for(mir_connection_platform_operation(
+                xmir_screen->conn,
+                msg,
+                &xmir_drm_set_gbm_device_response,
+                NULL));
+        mir_platform_message_release(msg);
+#pragma GCC diagnostic pop
+        /* In GBM mode no mir functions are used in any way.
+         * This means using the GBM device directly is safe.. */
+        xmir_screen->egl_display = eglGetDisplay(xmir_screen->gbm);
+    }
+    else
+        xmir_screen->egl_display = eglGetDisplay(mir_connection_get_egl_native_display(xmir_screen->conn));
+
+    if (xmir_screen->egl_display == EGL_NO_DISPLAY) {
+        ErrorF("eglGetDisplay() failed\n");
+        return FALSE;
+    }
+
+    eglBindAPI(!xmir_screen->gbm ? EGL_OPENGL_ES_API : EGL_OPENGL_API);
+
+    if (!eglInitialize(xmir_screen->egl_display, &major, &minor)) {
+        ErrorF("eglInitialize() failed\n");
+        return FALSE;
+    }
+
+    version = eglQueryString(xmir_screen->egl_display, EGL_VERSION);
+    ErrorF("glamor EGL version: %s\n", version);
+    ErrorF("glamor EGL extensions: %s\n", eglQueryString(xmir_screen->egl_display, EGL_EXTENSIONS));
+
+    egl_config = xmir_glamor_get_egl_config(xmir_screen);
+
+    xmir_screen->egl_context = eglCreateContext(xmir_screen->egl_display,
+                                                egl_config, EGL_NO_CONTEXT,
+                                                !xmir_screen->gbm ? gles2_attribs : NULL);
+    if (xmir_screen->egl_context == EGL_NO_CONTEXT) {
+        ErrorF("Failed to create EGL context: %i/%x\n", eglGetError(), eglGetError());
+        return FALSE;
+    }
+
+    if (!epoxy_has_egl_extension(xmir_screen->egl_display, "EGL_KHR_surfaceless_context")) {
+        xmir_screen->egl_surface = eglCreatePbufferSurface(xmir_screen->egl_display, egl_config, pbuffer_attribs);
+    }
+    else
+        xmir_screen->egl_surface = EGL_NO_SURFACE;
+
+    if (!eglMakeCurrent(xmir_screen->egl_display,
+                        xmir_screen->egl_surface, xmir_screen->egl_surface,
+                        xmir_screen->egl_context)) {
+        ErrorF("Failed to make EGL context current: %i/%x\n", eglGetError(), eglGetError());
+        return FALSE;
+    }
+    lastGLContext = xmir_screen->egl_context;
+
+    ErrorF("glamor GL version: %s\n", glGetString(GL_VERSION));
+    ErrorF("glamor GL extensions: %s\n", glGetString(GL_EXTENSIONS));
+    ErrorF("glamor GLSL version: %s\n", glGetString(GL_SHADING_LANGUAGE_VERSION));
+
+    if (!epoxy_has_gl_extension("GL_OES_EGL_image")) {
+        ErrorF("GL_OES_EGL_image not available\n");
+        return FALSE;
+    }
+
+    xmir_screen->glamor_has_GL_EXT_framebuffer_blit =
+        epoxy_has_gl_extension("GL_EXT_framebuffer_blit");
+
+    if (!xmir_screen->gbm && xmir_screen->glamor != glamor_egl_sync) {
+        xmir_screen->swap_context = eglCreateContext(xmir_screen->egl_display, egl_config, EGL_NO_CONTEXT, gles2_attribs);
+        if (!xmir_screen->swap_context) {
+            ErrorF("Failed to create EGL context: %i/%x\n", eglGetError(), eglGetError());
+            return FALSE;
+        }
+
+        if (xmir_screen->egl_surface)
+            xmir_screen->swap_surface = eglCreatePbufferSurface(xmir_screen->egl_display, egl_config, pbuffer_attribs);
+
+        xorg_list_init(&xmir_screen->swap_list);
+    }
+
+    return TRUE;
+}
+
+static Bool
+xmir_screen_init_glamor_drm(struct xmir_screen *xmir_screen)
+{
+    xmir_screen->drm_fd = xmir_screen->platform.fd[0];
+
+    xmir_screen->device_name = drmGetDeviceNameFromFd(xmir_screen->drm_fd);
+    if (!xmir_screen->device_name)
+        return FALSE;
+
+    return TRUE;
+}
+
+Bool
+xmir_screen_init_glamor(struct xmir_screen *xmir_screen)
+{
+    if (xmir_screen->platform.fd_items >= 1 &&
+        xmir_screen->doubled)
+        ErrorF("Disabling DRI2 support because of -2x\n");
+
+    if (xmir_screen->platform.fd_items >= 1 &&
+        !xmir_screen->doubled &&
+        xmir_screen->glamor == glamor_dri &&
+        !xmir_screen_init_glamor_drm(xmir_screen))
+        return FALSE;
+
+    return xmir_drm_init_egl(xmir_screen);
+}
+
+void
+xmir_glamor_fini(struct xmir_screen *xmir_screen)
+{
+    if (xmir_screen->thread) {
+        xmir_screen->alive = -1;
+
+        pthread_cond_signal(&xmir_screen->cond);
+        pthread_join(xmir_screen->thread, NULL);
+        pthread_cond_destroy(&xmir_screen->cond);
+        pthread_mutex_destroy(&xmir_screen->mutex);
+    }
+
+    if (xmir_screen->swap_context)
+        eglDestroyContext(xmir_screen->egl_display, xmir_screen->swap_context);
+
+    if (xmir_screen->swap_surface)
+        eglDestroySurface(xmir_screen->egl_display, xmir_screen->swap_surface);
+
+    lastGLContext = NULL;
+    if (!eglMakeCurrent(xmir_screen->egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT))
+        ErrorF("eglMakeCurrent failed: %x\n", eglGetError());
+    if (xmir_screen->egl_surface)
+        eglDestroySurface(xmir_screen->egl_display, xmir_screen->egl_surface);
+    eglDestroyContext(xmir_screen->egl_display, xmir_screen->egl_context);
+    eglTerminate(xmir_screen->egl_display);
+
+    if (xmir_screen->gbm)
+        gbm_device_destroy(xmir_screen->gbm);
+    free(xmir_screen->device_name);
+}
+
+static void
+xmir_glamor_get_name_from_bo(int drm_fd, struct gbm_bo *bo, int *name)
+{
+    struct drm_gem_flink flink;
+    unsigned handle = gbm_bo_get_handle(bo).u32;
+
+    flink.handle = handle;
+    if (ioctl(drm_fd, DRM_IOCTL_GEM_FLINK, &flink) < 0)
+        *name = -1;
+    else
+        *name = flink.name;
+}
+
+static int
+xmir_glamor_get_fd_from_bo(int gbm_fd, struct gbm_bo *bo, int *fd)
+{
+    union gbm_bo_handle handle;
+    struct drm_prime_handle args;
+
+    handle = gbm_bo_get_handle(bo);
+    args.handle = handle.u32;
+    args.flags = DRM_CLOEXEC;
+    if (ioctl(gbm_fd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &args))
+        return FALSE;
+    *fd = args.fd;
+    return TRUE;
+}
+
+int
+glamor_egl_dri3_fd_name_from_tex(ScreenPtr screen,
+                                 PixmapPtr pixmap,
+                                 unsigned int tex,
+                                 Bool want_name, CARD16 *stride, CARD32 *size)
+{
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    struct xmir_pixmap *xmir_pixmap = xmir_pixmap_get(pixmap);
+    struct glamor_screen_private *glamor_priv =
+        glamor_get_screen_private(screen);
+    struct gbm_bo *bo;
+    int fd = -1;
+
+    EGLint attribs[] = {
+        EGL_IMAGE_PRESERVED_KHR, EGL_TRUE,
+        EGL_GL_TEXTURE_LEVEL_KHR, 0,
+        EGL_NONE
+    };
+
+    glamor_make_current(glamor_priv);
+
+    if (!xmir_pixmap) {
+        void *image;
+
+        xmir_pixmap = calloc(sizeof(*xmir_pixmap), 1);
+        xmir_pixmap_set(pixmap, xmir_pixmap);
+
+        xmir_pixmap->fake_back = true;
+
+        image = eglCreateImageKHR(xmir_screen->egl_display,
+                                  xmir_screen->egl_context,
+                                  EGL_GL_TEXTURE_2D_KHR,
+                                  (EGLClientBuffer) (uintptr_t)
+                                  tex, attribs);
+        if (image == EGL_NO_IMAGE_KHR)
+            goto failure;
+        xmir_pixmap->image = image;
+
+        glamor_set_pixmap_type(pixmap, GLAMOR_TEXTURE_DRM);
+        xmir_pixmap->bo = gbm_bo_import(xmir_screen->gbm, GBM_BO_IMPORT_EGL_IMAGE, image, 0);
+    }
+    bo = xmir_pixmap->bo;
+
+    if (!bo)
+        goto failure;
+
+    pixmap->devKind = gbm_bo_get_stride(bo);
+
+    if (want_name)
+        xmir_glamor_get_name_from_bo(xmir_screen->drm_fd, bo, &fd);
+    else
+        xmir_glamor_get_fd_from_bo(xmir_screen->drm_fd, bo, &fd);
+
+    *stride = pixmap->devKind;
+    *size = pixmap->devKind * gbm_bo_get_height(bo);
+
+ failure:
+    return fd;
+}
+
+static PixmapPtr
+xmir_glamor_create_pixmap(ScreenPtr screen,
+                          int width, int height, int depth, unsigned int hint)
+{
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+
+    if (width > 0 && height > 0 && depth >= 24 &&
+        (hint == 0 ||
+         hint == CREATE_PIXMAP_USAGE_BACKING_PIXMAP ||
+         hint == CREATE_PIXMAP_USAGE_SHARED ||
+         hint == XMIR_CREATE_PIXMAP_USAGE_FLIP)) {
+        struct xmir_pixmap *xmir_pixmap = malloc(sizeof(*xmir_pixmap));
+        PixmapPtr pixmap = NULL;
+        struct gbm_bo *bo = NULL;
+        void *image = NULL;
+        unsigned int tex = 0;
+
+        if (!xmir_pixmap)
+            goto free;
+
+        pixmap = glamor_create_pixmap(screen, width, height, depth, GLAMOR_CREATE_PIXMAP_NO_TEXTURE);
+        if (!pixmap)
+            goto free;
+
+        glamor_set_pixmap_type(pixmap, GLAMOR_TEXTURE_DRM);
+
+        if (hint != XMIR_CREATE_PIXMAP_USAGE_FLIP) {
+            bo = gbm_bo_create(xmir_screen->gbm, width, height,
+                               GBM_FORMAT_ARGB8888,
+                               GBM_BO_USE_RENDERING);
+
+            if (!bo)
+                goto free;
+
+            image = eglCreateImageKHR(xmir_screen->egl_display, xmir_screen->egl_context, EGL_NATIVE_PIXMAP_KHR, bo, NULL);
+            if (!image)
+                goto free;
+
+            glGenTextures(1, &tex);
+            glBindTexture(GL_TEXTURE_2D, tex);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+
+            glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, image);
+            glBindTexture(GL_TEXTURE_2D, 0);
+            glamor_set_pixmap_texture(pixmap, tex);
+        }
+
+        xmir_pixmap->image = image;
+        xmir_pixmap->bo = bo;
+        xmir_pixmap_set(pixmap, xmir_pixmap);
+        xmir_pixmap->fake_back = true;
+        if (bo)
+            pixmap->devKind = gbm_bo_get_stride(bo);
+
+        if (!glGetError())
+            return pixmap;
+
+        ErrorF("Failed to allocate pixmap - a opengl error occured!\n");
+
+free:
+        if (tex)
+            glDeleteTextures(1, &tex);
+
+        if (image)
+            eglDestroyImageKHR(xmir_screen->egl_display, image);
+
+        if (pixmap)
+            glamor_destroy_pixmap(pixmap);
+
+        if (bo)
+            gbm_bo_destroy(bo);
+
+        free(xmir_pixmap);
+        return NULL;
+    }
+
+    return glamor_create_pixmap(screen, width, height, depth, hint);
+}
+
+static Bool
+xmir_glamor_destroy_pixmap(PixmapPtr pixmap)
+{
+    struct xmir_pixmap *xmir_pixmap;
+
+    if (pixmap->refcnt == 1 && (xmir_pixmap = xmir_pixmap_get(pixmap))) {
+        ScreenPtr screen = pixmap->drawable.pScreen;
+        struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+        Bool ret;
+
+        ret = glamor_destroy_pixmap(pixmap);
+        if (!ret)
+            return ret;
+        glamor_block_handler(screen);
+
+        if (xmir_pixmap->image)
+            eglDestroyImageKHR(xmir_screen->egl_display, xmir_pixmap->image);
+        if (xmir_pixmap->bo)
+            gbm_bo_destroy(xmir_pixmap->bo);
+        free(xmir_pixmap);
+        return ret;
+    }
+
+    return glamor_destroy_pixmap(pixmap);
+}
+
+Bool
+xmir_glamor_init(struct xmir_screen *xmir_screen)
+{
+    ScreenPtr screen = xmir_screen->screen;
+
+    if (xmir_screen->egl_context == EGL_NO_CONTEXT) {
+        ErrorF("Disabling glamor and dri2, EGL setup failed\n");
+        return FALSE;
+    }
+
+    if (!glamor_init(screen,
+                     GLAMOR_USE_EGL_SCREEN |
+                     GLAMOR_NO_DRI3)) {
+        ErrorF("Failed to initialize glamor\n");
+        return FALSE;
+    }
+
+    if (xmir_screen->swap_context) {
+        pthread_mutex_init(&xmir_screen->mutex, NULL);
+        pthread_cond_init(&xmir_screen->cond, NULL);
+        pthread_create(&xmir_screen->thread, NULL, xmir_glamor_flip, xmir_screen);
+    }
+
+    if (xmir_screen->gbm) {
+        screen->CreatePixmap = xmir_glamor_create_pixmap;
+        screen->DestroyPixmap = xmir_glamor_destroy_pixmap;
+
+        /* Tell the core that we have the interfaces for import/export
+         * of pixmaps.
+         */
+        glamor_enable_dri3(screen);
+    }
+
+    return TRUE;
+}
--- /dev/null
+++ b/hw/xmir/xmir-input.c
@@ -0,0 +1,650 @@
+/*
+ * Copyright © 2015-2017 Canonical Ltd
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#include "xmir.h"
+
+#include <linux/input.h>
+
+#include <sys/mman.h>
+#include <xkbsrv.h>
+#include <xserver-properties.h>
+#include <inpututils.h>
+
+static void
+xmir_pointer_control(DeviceIntPtr device, PtrCtrl *ctrl)
+{
+    /* Nothing to do, dix handles all settings */
+}
+
+static int
+xmir_pointer_proc(DeviceIntPtr device, int what)
+{
+#define NBUTTONS 10
+#define NAXES 4
+    BYTE map[NBUTTONS + 1];
+    int i = 0;
+    Atom btn_labels[NBUTTONS] = { 0 };
+    Atom axes_labels[NAXES] = { 0 };
+
+    switch (what) {
+    case DEVICE_INIT:
+        device->public.on = FALSE;
+
+        for (i = 1; i <= NBUTTONS; i++)
+            map[i] = i;
+
+        btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
+        btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
+        btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
+        btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
+        btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
+        btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
+        btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
+        /* Don't know about the rest */
+
+        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_X);
+        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_Y);
+        axes_labels[2] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_HWHEEL);
+        axes_labels[3] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_WHEEL);
+
+        if (!InitValuatorClassDeviceStruct(device, NAXES, btn_labels,
+                                           GetMotionHistorySize(), Absolute))
+            return BadValue;
+
+        /* Valuators */
+        InitValuatorAxisStruct(device, 0, axes_labels[0],
+                               0, 0xFFFF, 10000, 0, 10000, Absolute);
+        InitValuatorAxisStruct(device, 1, axes_labels[1],
+                               0, 0xFFFF, 10000, 0, 10000, Absolute);
+        InitValuatorAxisStruct(device, 2, axes_labels[2],
+                               NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Relative);
+        InitValuatorAxisStruct(device, 3, axes_labels[3],
+                               NO_AXIS_LIMITS, NO_AXIS_LIMITS, 0, 0, 0, Relative);
+
+        SetScrollValuator(device, 2, SCROLL_TYPE_HORIZONTAL, 1.0, SCROLL_FLAG_NONE);
+        SetScrollValuator(device, 3, SCROLL_TYPE_VERTICAL, 1.0, SCROLL_FLAG_PREFERRED);
+
+        if (!InitPtrFeedbackClassDeviceStruct(device, xmir_pointer_control))
+            return BadValue;
+
+        if (!InitButtonClassDeviceStruct(device, 3, btn_labels, map))
+            return BadValue;
+
+        return Success;
+
+    case DEVICE_ON:
+        device->public.on = TRUE;
+        return Success;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+        device->public.on = FALSE;
+        return Success;
+    }
+
+    return BadMatch;
+
+#undef NBUTTONS
+#undef NAXES
+}
+
+static void
+xmir_keyboard_control(DeviceIntPtr device, KeybdCtrl *ctrl)
+{
+}
+
+static int
+xmir_keyboard_proc(DeviceIntPtr device, int what)
+{
+    switch (what) {
+    case DEVICE_INIT:
+        device->public.on = FALSE;
+        if (!InitKeyboardDeviceStructFromString(device,
+                                                NULL /*xmir_input->keymap*/, 0,
+                                                NULL, xmir_keyboard_control))
+            return BadValue;
+
+        return Success;
+    case DEVICE_ON:
+        device->public.on = TRUE;
+        return Success;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+        device->public.on = FALSE;
+        return Success;
+    }
+
+    return BadMatch;
+}
+
+static void
+pointer_convert_xy(struct xmir_input *xmir_input,
+                   struct xmir_window *xmir_window,
+                   int *x, int *y)
+{
+    struct xmir_screen *xmir_screen = xmir_screen_get(xmir_window->window->drawable.pScreen);
+    bool reflect_x = false;
+    bool reflect_y = false;
+    bool swap_xy = false;
+    int dx = xmir_window->window->drawable.x;
+    int dy = xmir_window->window->drawable.y;
+    int sx = *x, sy = *y;
+    int scale = 1 + xmir_screen->doubled;
+    int w = xmir_window->window->drawable.width;
+    int h = xmir_window->window->drawable.height;
+
+    /* reflection test parameters */
+    bool magic_x_invert = false, magic_y_invert = false;
+
+    DebugF("Raw input %i,%i in window (%i,%i)->(%i,%i) orientation %i and scale %i\n",
+           *x, *y, dx, dy, dx + w, dy + h, xmir_window->orientation, scale);
+
+    if (magic_x_invert)
+        reflect_x = !reflect_x;
+
+    if (magic_y_invert)
+        reflect_y = !reflect_y;
+
+    switch (xmir_window->orientation) {
+    case 90:
+        reflect_x = !reflect_x;
+        swap_xy = true;
+        break;
+    case 180:
+        reflect_x = !reflect_x;
+        reflect_y = !reflect_y;
+        break;
+    case 270:
+        reflect_y = !reflect_y;
+        swap_xy = true;
+        break;
+    }
+
+    if (!swap_xy) {
+        sx = *x;
+        sy = *y;
+    }
+    else {
+        sx = *y;
+        sy = *x;
+    }
+
+    if (!reflect_x)
+        *x = (sx * scale) + dx;
+    else
+        *x = w + dx - (sx * scale);
+
+    if (!reflect_y)
+        *y = (sy * scale) + dy;
+    else
+        *y = h + dy - (sy * scale);
+
+    DebugF("Converted to %i, %i\n", *x, *y);
+}
+
+static Bool
+pointer_ensure_focus(struct xmir_input *xmir_input,
+                     struct xmir_window *xmir_window,
+                     DeviceIntPtr dev, int sx, int sy)
+{
+    ScreenPtr screen = xmir_window->window->drawable.pScreen;
+
+    if (xmir_input->focus_window == xmir_window)
+        return FALSE;
+
+    if (xmir_input->focus_window) {
+        xmir_input->focus_window = NULL;
+        CheckMotion(NULL, GetMaster(dev, MASTER_POINTER));
+    }
+
+    xmir_input->focus_window = xmir_window;
+
+    pointer_convert_xy(xmir_input, xmir_window, &sx, &sy);
+
+    (screen->SetCursorPosition) (dev, screen, sx, sy, TRUE);
+    CheckMotion(NULL, GetMaster(dev, MASTER_POINTER));
+
+    return TRUE;
+}
+
+static void
+pointer_handle_motion(struct xmir_input *xmir_input,
+                      struct xmir_window *xmir_window,
+                      MirPointerEvent const *pev)
+{
+    int sx = mir_pointer_event_axis_value(pev, mir_pointer_axis_x);
+    int sy = mir_pointer_event_axis_value(pev, mir_pointer_axis_y);
+    float vscroll, hscroll;
+    ValuatorMask mask;
+
+    pointer_ensure_focus(xmir_input, xmir_window, xmir_input->pointer, sx, sy);
+
+    pointer_convert_xy(xmir_input, xmir_window, &sx, &sy);
+
+    valuator_mask_zero(&mask);
+    valuator_mask_set(&mask, 0, sx);
+    valuator_mask_set(&mask, 1, sy);
+    QueuePointerEvents(xmir_input->pointer, MotionNotify, 0,
+                       POINTER_ABSOLUTE | POINTER_SCREEN, &mask);
+
+    vscroll = mir_pointer_event_axis_value(pev, mir_pointer_axis_vscroll);
+    hscroll = mir_pointer_event_axis_value(pev, mir_pointer_axis_hscroll);
+    if (vscroll || hscroll) {
+        valuator_mask_zero(&mask);
+        valuator_mask_set_double(&mask, 3, -vscroll);
+        valuator_mask_set_double(&mask, 2, hscroll);
+        QueuePointerEvents(xmir_input->pointer, MotionNotify, 0,
+                           POINTER_RELATIVE, &mask);
+    }
+}
+
+static void
+pointer_handle_button(struct xmir_input *xmir_input,
+                      struct xmir_window *xmir_window,
+                      MirPointerEvent const *pev)
+{
+    DeviceIntPtr dev = xmir_input->pointer;
+    struct {
+        MirPointerButton mir_button;
+        int x_button;
+    } map[3] = {
+        {mir_pointer_button_primary, 1},   /* Usually left button */
+        {mir_pointer_button_secondary, 3}, /* Middle button */
+        {mir_pointer_button_tertiary, 2},  /* Right button */
+    };
+    int i;
+    ValuatorMask mask;
+
+    valuator_mask_zero(&mask);
+    for (i = 0; i < 3; ++i) {
+        MirPointerButton mir_button = map[i].mir_button;
+        int x_button = map[i].x_button;
+        int oldstate = BitIsOn(dev->button->down, x_button) ?
+                       ButtonPress : ButtonRelease;
+        int newstate = mir_pointer_event_button_state(pev, mir_button) ?
+                       ButtonPress : ButtonRelease;
+
+        if (oldstate != newstate)
+            QueuePointerEvents(dev, newstate, x_button, 0, &mask);
+    }
+
+    /* XXX: Map rest of input buttons too! */
+}
+
+static DeviceIntPtr
+add_device(struct xmir_input *xmir_input,
+           const char *driver, DeviceProc device_proc)
+{
+    DeviceIntPtr dev = NULL;
+    static Atom type_atom;
+    char name[32];
+
+    dev = AddInputDevice(serverClient, device_proc, TRUE);
+    if (dev == NULL)
+        return NULL;
+
+    if (type_atom == None)
+        type_atom = MakeAtom(driver, strlen(driver), TRUE);
+    snprintf(name, sizeof name, "%s:%d", driver, xmir_input->id);
+    AssignTypeAndName(dev, type_atom, name);
+    dev->public.devicePrivate = xmir_input;
+    dev->type = SLAVE;
+    dev->spriteInfo->spriteOwner = FALSE;
+
+    return dev;
+}
+
+static void
+xmir_input_destroy(struct xmir_input *xmir_input)
+{
+    RemoveDevice(xmir_input->pointer, FALSE);
+    RemoveDevice(xmir_input->keyboard, FALSE);
+    free(xmir_input);
+}
+
+Bool
+LegalModifier(unsigned int key, DeviceIntPtr pDev)
+{
+    return TRUE;
+}
+
+void
+ProcessInputEvents(void)
+{
+    mieqProcessInputEvents();
+}
+
+void
+DDXRingBell(int volume, int pitch, int duration)
+{
+}
+
+static WindowPtr
+xmir_xy_to_window(ScreenPtr screen, SpritePtr sprite, int x, int y)
+{
+    struct xmir_input *xmir_input = NULL;
+    DeviceIntPtr device;
+
+    for (device = inputInfo.devices; device; device = device->next) {
+        if (device->deviceProc == xmir_pointer_proc &&
+            device->spriteInfo->sprite == sprite) {
+            xmir_input = device->public.devicePrivate;
+            break;
+        }
+    }
+
+    if (xmir_input == NULL) {
+        /* XTEST device */
+        sprite->spriteTraceGood = 1;
+        return sprite->spriteTrace[0];
+    }
+
+    if (xmir_input->focus_window) {
+        sprite->spriteTraceGood = 2;
+        sprite->spriteTrace[1] = xmir_input->focus_window->window;
+        return miSpriteTrace(sprite, x, y);
+    }
+    else {
+        sprite->spriteTraceGood = 1;
+        return sprite->spriteTrace[0];
+    }
+}
+
+static void
+fake_touch_move(struct xmir_input *xmir_input,
+                struct xmir_window *xmir_window,
+                int sx, int sy)
+{
+    ValuatorMask mask;
+
+    pointer_convert_xy(xmir_input, xmir_window, &sx, &sy);
+
+    valuator_mask_zero(&mask);
+    valuator_mask_set(&mask, 0, sx);
+    valuator_mask_set(&mask, 1, sy);
+
+    QueuePointerEvents(xmir_input->touch, MotionNotify, 0,
+                       POINTER_ABSOLUTE | POINTER_SCREEN, &mask);
+}
+
+static void
+xmir_window_handle_input_event(struct xmir_input *xmir_input,
+                               struct xmir_window *xmir_window,
+                               MirInputEvent const* ev)
+{
+    switch (mir_input_event_get_type(ev)) {
+    case mir_input_event_type_key: {
+        MirKeyboardEvent const *kev;
+        MirKeyboardAction action;
+        int code;
+
+        kev = mir_input_event_get_keyboard_event(ev);
+        action = mir_keyboard_event_action(kev);
+        code = mir_keyboard_event_scan_code(kev) + 8;
+
+        /*
+         * Note: mir_keyboard_action_repeat must KeyRelease then KeyPress
+         * because it is already preceded by mir_keyboard_action_down and will
+         * be followed by mir_keyboard_action_up.
+         */
+        if (action == mir_keyboard_action_up ||
+            action == mir_keyboard_action_repeat) {
+            QueueKeyboardEvents(xmir_input->keyboard, KeyRelease, code);
+        }
+        if (action == mir_keyboard_action_down ||
+            action == mir_keyboard_action_repeat) {
+            QueueKeyboardEvents(xmir_input->keyboard, KeyPress, code);
+        }
+        break;
+    }
+    case mir_input_event_type_touch: {
+        MirTouchEvent const *tev;
+        int i = 0, count, sx, sy;
+        ValuatorMask mask;
+
+        tev = mir_input_event_get_touch_event(ev);
+        count = mir_touch_event_point_count(tev);
+
+        /* Do we really need this multifinger tracking at all?... */
+        if (count < 1) {
+            xmir_input->touch_id = -1;
+            break;
+        }
+
+        if (xmir_input->touch_id != -1) {
+            for (i = 0; i < count; ++i)
+                if (mir_touch_event_id(tev, i) == xmir_input->touch_id)
+                    break;
+        }
+        if (i >= count) {
+            for (i = 0; i < count; ++i)
+                if (mir_touch_event_action(tev, i) == mir_touch_action_down)
+                    break;
+        }
+
+        if (i >= count)
+            break;
+
+        sx = mir_touch_event_axis_value(tev, i, mir_touch_axis_x);
+        sy = mir_touch_event_axis_value(tev, i, mir_touch_axis_y);
+        valuator_mask_zero(&mask);
+
+        switch (mir_touch_event_action(tev, i)) {
+        case mir_touch_action_up:
+            fake_touch_move(xmir_input, xmir_window, sx, sy);
+            QueuePointerEvents(xmir_input->touch, ButtonRelease, 1, 0, &mask);
+            xmir_input->touch_id = -1;
+            break;
+        case mir_touch_action_down:
+            xmir_input->touch_id = mir_touch_event_id(tev, i);
+            if (!pointer_ensure_focus(xmir_input,
+                                      xmir_window,
+                                      xmir_input->touch,
+                                      sx, sy))
+                fake_touch_move(xmir_input, xmir_window, sx, sy);
+            QueuePointerEvents(xmir_input->touch, ButtonPress, 1, 0, &mask);
+            break;
+        case mir_touch_action_change:
+            fake_touch_move(xmir_input, xmir_window, sx, sy);
+            break;
+        default:
+            break;
+        }
+        break;
+
+
+    }
+    case mir_input_event_type_pointer: {
+        MirPointerEvent const *pev;
+
+        pev = mir_input_event_get_pointer_event(ev);
+        switch (mir_pointer_event_action(pev)) {
+        case mir_pointer_action_button_up:
+        case mir_pointer_action_button_down:
+            pointer_handle_motion(xmir_input, xmir_window, pev);
+            pointer_handle_button(xmir_input, xmir_window, pev);
+            break;
+        case mir_pointer_action_motion:
+            pointer_handle_motion(xmir_input, xmir_window, pev);
+            break;
+        default:
+            ErrorF("Unknown action: %u\n", mir_pointer_event_action(pev));
+        case mir_pointer_action_enter:
+        case mir_pointer_action_leave:
+            break;
+        }
+        break;
+    }
+    default: ErrorF("Unknown input type: %u\n", mir_input_event_get_type(ev));
+    }
+}
+
+static void
+xmir_handle_keymap_event(struct xmir_input *xmir_input,
+                         MirKeymapEvent const* ev)
+{
+    char * buffer = NULL;
+    size_t length = 0;
+    DeviceIntPtr master;
+    XkbDescPtr xkb;
+    XkbChangesRec changes = { 0 };
+
+    mir_keymap_event_get_keymap_buffer(ev, (char const **)&buffer, &length);
+
+    xkb = XkbCompileKeymapFromString(xmir_input->keyboard, buffer, length);
+
+    XkbUpdateDescActions(xkb, xkb->min_key_code, XkbNumKeys(xkb), &changes);
+
+    XkbDeviceApplyKeymap(xmir_input->keyboard, xkb);
+
+    master = GetMaster(xmir_input->keyboard, MASTER_KEYBOARD);
+    if (master && master->lastSlave == xmir_input->keyboard)
+        XkbDeviceApplyKeymap(master, xkb);
+
+    XkbFreeKeyboard(xkb, XkbAllComponentsMask, TRUE);
+}
+
+static void
+xmir_handle_surface_event_in_main_thread(struct xmir_screen *xmir_screen,
+                                         struct xmir_window *xmir_window,
+                                         void *arg)
+{
+    const MirEvent *ev = arg;
+    struct xmir_input *xmir_input;
+
+    xmir_input = xorg_list_first_entry(&xmir_screen->input_list,
+                                       struct xmir_input,
+                                       link);
+    switch (mir_event_get_type(ev))
+    {
+    case mir_event_type_input:
+        xmir_window_handle_input_event(xmir_input,
+                                       xmir_window,
+                                       mir_event_get_input_event(ev));
+        break;
+    case mir_event_type_window: {
+        const MirWindowEvent *surface = mir_event_get_window_event(ev);
+        xmir_handle_surface_event(xmir_window,
+                                  mir_window_event_get_attribute(surface),
+                                  mir_window_event_get_attribute_value(surface));
+        }
+        break;
+    case mir_event_type_resize: {
+        WindowPtr window = xmir_window->window;
+        const MirResizeEvent *resize = mir_event_get_resize_event(ev);
+        unsigned future_width = mir_resize_event_get_width(resize);
+        unsigned future_height = mir_resize_event_get_height(resize);
+        XMIR_DEBUG(("Mir surface for win %p resized to %ux%u (buffers arriving soon)\n",
+                    window, future_width, future_height));
+        xmir_window->surface_width = future_width;
+        xmir_window->surface_height = future_height;
+        if (xmir_window->damage)
+            DamageDamageRegion(&window->drawable, &xmir_window->region);
+        }
+        break;
+    case mir_event_type_prompt_session_state_change:
+        ErrorF("No idea about prompt_session_state_change\n");
+        break;
+    case mir_event_type_orientation: {
+        const MirOrientationEvent *orientation = mir_event_get_orientation_event(ev);
+        xmir_output_handle_orientation(xmir_window,
+                                       mir_orientation_event_get_direction(orientation));
+        }
+        break;
+    case mir_event_type_close_window:
+        xmir_close_surface(xmir_window);
+        break;
+    case mir_event_type_window_output:
+        break;
+    case mir_event_type_keymap:
+        xmir_handle_keymap_event(xmir_input, mir_event_get_keymap_event(ev));
+        break;
+    case mir_event_type_input_device_state:
+        break;
+    default:
+        ErrorF("Received an unknown %u event\n", mir_event_get_type(ev));
+        break;
+    }
+    mir_event_unref(ev);
+}
+
+void
+xmir_surface_handle_event(MirWindow *surface, MirEvent const* ev,
+                          void *context)
+{
+    struct xmir_window *xmir_window = context;
+    struct xmir_screen *xmir_screen = xmir_window->xmir_screen;
+
+    /* We are in a Mir event thread, so unsafe to do X things. Post the event
+     * to the X event loop thread...
+     */
+    xmir_post_to_eventloop(&xmir_handle_surface_event_in_main_thread,
+        xmir_screen, xmir_window, (void*)mir_event_ref(ev));
+}
+
+void
+InitInput(int argc, char *argv[])
+{
+    ScreenPtr pScreen = screenInfo.screens[0];
+    struct xmir_screen *xmir_screen = xmir_screen_get(pScreen);
+    struct xmir_input *xmir_input;
+
+    if (xmir_screen->rootless)
+        pScreen->XYToWindow = xmir_xy_to_window;
+
+    mieqInit();
+
+    xmir_input = calloc(1, sizeof(*xmir_input));
+    if (!xmir_input)
+        FatalError("Failed to allocate input\n");
+
+    xmir_input->xmir_screen = xmir_screen;
+    xorg_list_add(&xmir_input->link, &xmir_screen->input_list);
+    xmir_input->touch_id = -1;
+    xmir_input->pointer = add_device(xmir_input,
+                                     "xmir-pointer",
+                                     xmir_pointer_proc);
+    xmir_input->touch = add_device(xmir_input,
+                                   "xmir-fake-touch-pointer",
+                                   xmir_pointer_proc);
+    xmir_input->keyboard = add_device(xmir_input,
+                                      "xmir-keyboard",
+                                      xmir_keyboard_proc);
+}
+
+void
+CloseInput(void)
+{
+    ScreenPtr pScreen = screenInfo.screens[0];
+    struct xmir_screen *xmir_screen = xmir_screen_get(pScreen);
+    struct xmir_input *xmir_input, *next_xmir_input;
+
+    xorg_list_for_each_entry_safe(xmir_input, next_xmir_input,
+                                  &xmir_screen->input_list, link)
+        xmir_input_destroy(xmir_input);
+
+    mieqFini();
+}
--- /dev/null
+++ b/hw/xmir/xmir-output.c
@@ -0,0 +1,501 @@
+/*
+ * Copyright © 2015-2017 Canonical Ltd
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "xmir.h"
+#include <randrstr.h>
+#include "glamor_priv.h"
+#include "mipointer.h"
+
+static Rotation
+to_rr_rotation(MirOrientation orient)
+{
+    switch (orient) {
+    default: return RR_Rotate_0;
+    case mir_orientation_left: return RR_Rotate_90;
+    case mir_orientation_inverted: return RR_Rotate_180;
+    case mir_orientation_right: return RR_Rotate_270;
+    }
+}
+
+Bool
+xmir_output_dpms(struct xmir_screen *xmir_screen, int mode)
+{
+    MirDisplayConfig *display_config = xmir_screen->display;
+    MirPowerMode mir_mode = mir_power_mode_on;
+    Bool unchanged = TRUE;
+    int num_outputs;
+
+    if (xmir_screen->rootless || xmir_screen->windowed)
+        return FALSE;
+
+    switch (mode) {
+    case DPMSModeOn:      mir_mode = mir_power_mode_on; break;
+    case DPMSModeStandby: mir_mode = mir_power_mode_standby; break;
+    case DPMSModeSuspend: mir_mode = mir_power_mode_suspend; break;
+    case DPMSModeOff:     mir_mode = mir_power_mode_off; break;
+    }
+
+    DebugF("Setting DPMS mode to %d\n", mode);
+
+    num_outputs = mir_display_config_get_num_outputs(display_config);
+    for (int i = 0; i < num_outputs; i++) {
+        MirOutput *output = mir_display_config_get_mutable_output(display_config, i);
+        MirPowerMode power_mode = mir_output_get_power_mode(output);
+        if (power_mode != mir_mode) {
+            mir_output_set_power_mode(output, mir_mode);
+            unchanged = FALSE;
+        }
+    }
+
+    if (!unchanged)
+        mir_connection_apply_session_display_config(xmir_screen->conn,
+                                                    xmir_screen->display);
+
+    return TRUE;
+}
+
+static void
+xmir_output_update(struct xmir_output *xmir_output, MirOutput const *mir_output)
+{
+    MirOutputConnectionState connection_state;
+    bool output_is_connected;
+
+    connection_state = mir_output_get_connection_state(mir_output);
+    output_is_connected = !(connection_state == mir_output_connection_state_disconnected);
+
+    RROutputSetConnection(xmir_output->randr_output,
+                          output_is_connected ? RR_Connected : RR_Disconnected);
+    RROutputSetSubpixelOrder(xmir_output->randr_output, SubPixelUnknown);
+
+    if (output_is_connected) {
+        MirOutputMode const *mode = mir_output_get_current_mode(mir_output);
+        RRModePtr randr_mode;
+        double refresh_rate;
+
+        xmir_output->width = mir_output_mode_get_width(mode);
+        xmir_output->height = mir_output_mode_get_height(mode);
+        xmir_output->x = mir_output_get_position_x(mir_output);
+        xmir_output->y = mir_output_get_position_y(mir_output);
+
+        refresh_rate = mir_output_mode_get_refresh_rate(mode);
+        randr_mode = xmir_cvt(xmir_output->width, xmir_output->height,
+                              refresh_rate, 0, 0);
+        /* Odd resolutions like 1366x768 don't show correctly otherwise */
+        randr_mode->mode.width = mir_output_mode_get_width(mode);
+        randr_mode->mode.height = mir_output_mode_get_height(mode);
+        sprintf(randr_mode->name, "%dx%d",
+                randr_mode->mode.width,
+                randr_mode->mode.height);
+
+        RROutputSetPhysicalSize(xmir_output->randr_output,
+                                mir_output_get_physical_width_mm(mir_output),
+                                mir_output_get_physical_height_mm(mir_output));
+        RROutputSetModes(xmir_output->randr_output, &randr_mode, 1, 1);
+
+        /* TODO: Hook up subpixel order when available (LP: #1393578) */
+        RRCrtcNotify(xmir_output->randr_crtc, randr_mode,
+                     xmir_output->x, xmir_output->y,
+                     to_rr_rotation(mir_output_get_orientation(mir_output)),
+                     NULL, 1, &xmir_output->randr_output);
+    }
+    else {
+        xmir_output->width = 0;
+        xmir_output->height = 0;
+        xmir_output->x = 0;
+        xmir_output->y = 0;
+
+        RROutputSetPhysicalSize(xmir_output->randr_output, 0, 0);
+        RROutputSetModes(xmir_output->randr_output, NULL, 0, 0);
+
+        RRCrtcNotify(xmir_output->randr_crtc, NULL,
+                     0, 0, RR_Rotate_0, NULL, 1, &xmir_output->randr_output);
+    }
+}
+
+static void
+xmir_screen_update_windowed_output(struct xmir_screen *xmir_screen)
+{
+    struct xmir_output *xmir_output = xmir_screen->windowed;
+    RRModePtr randr_mode;
+
+    RROutputSetConnection(xmir_output->randr_output, RR_Connected);
+    RROutputSetSubpixelOrder(xmir_output->randr_output, SubPixelUnknown);
+
+    xmir_output->width = xmir_screen->screen->width;
+    xmir_output->height = xmir_screen->screen->height;
+    xmir_output->x = 0;
+    xmir_output->y = 0;
+
+    randr_mode = xmir_cvt(xmir_output->width, xmir_output->height, 60, 0, 0);
+    randr_mode->mode.width = xmir_output->width;
+    randr_mode->mode.height = xmir_output->height;
+    sprintf(randr_mode->name, "%dx%d",
+            randr_mode->mode.width, randr_mode->mode.height);
+
+    RROutputSetPhysicalSize(xmir_output->randr_output, 0, 0);
+    RROutputSetModes(xmir_output->randr_output, &randr_mode, 1, 1);
+    RRCrtcNotify(xmir_output->randr_crtc, randr_mode,
+                 xmir_output->x, xmir_output->y,
+                 RR_Rotate_0, NULL, 1, &xmir_output->randr_output);
+}
+
+static void
+xmir_output_screen_resized(struct xmir_screen *xmir_screen)
+{
+    ScreenPtr screen = xmir_screen->screen;
+    struct xmir_output *xmir_output;
+    int width, height;
+
+    width = 0;
+    height = 0;
+    xorg_list_for_each_entry(xmir_output, &xmir_screen->output_list, link) {
+        if (width < xmir_output->x + xmir_output->width)
+            width = xmir_output->x + xmir_output->width;
+        if (height < xmir_output->y + xmir_output->height)
+            height = xmir_output->y + xmir_output->height;
+    }
+
+    screen->width = width;
+    screen->height = height;
+    if (ConnectionInfo)
+        RRScreenSizeNotify(xmir_screen->screen);
+    update_desktop_dimensions();
+}
+
+static struct xmir_output*
+xmir_output_create(struct xmir_screen *xmir_screen, const char *name)
+{
+    struct xmir_output *xmir_output;
+
+    xmir_output = calloc(sizeof *xmir_output, 1);
+    if (xmir_output == NULL) {
+        FatalError("No memory for creating output\n");
+        return NULL;
+    }
+
+    xmir_output->xmir_screen = xmir_screen;
+    xmir_output->randr_crtc = RRCrtcCreate(xmir_screen->screen, xmir_output);
+    xmir_output->randr_output = RROutputCreate(xmir_screen->screen,
+                                               name, strlen(name),
+                                               xmir_output);
+
+    RRCrtcGammaSetSize(xmir_output->randr_crtc, 256);
+    RROutputSetCrtcs(xmir_output->randr_output, &xmir_output->randr_crtc, 1);
+    xorg_list_append(&xmir_output->link, &xmir_screen->output_list);
+    return xmir_output;
+}
+
+void
+xmir_output_destroy(struct xmir_output *xmir_output)
+{
+    xorg_list_del(&xmir_output->link);
+    free(xmir_output);
+}
+
+static Bool
+xmir_randr_get_info(ScreenPtr pScreen, Rotation * rotations)
+{
+    *rotations = 0;
+
+    return TRUE;
+}
+
+static Bool
+xmir_randr_set_config(ScreenPtr pScreen,
+                     Rotation rotation, int rate, RRScreenSizePtr pSize)
+{
+    return FALSE;
+}
+
+static void
+xmir_update_config(struct xmir_screen *xmir_screen)
+{
+    MirDisplayConfig *new_config;
+    struct xmir_output *xmir_output;
+    int old_num_outputs, new_num_outputs;
+    MirOutput const *mir_output;
+    int i;
+
+    if (xmir_screen->windowed)
+        return;
+
+    new_config = mir_connection_create_display_configuration(xmir_screen->conn);
+    new_num_outputs = mir_display_config_get_num_outputs(new_config);
+    old_num_outputs = mir_display_config_get_num_outputs(xmir_screen->display);
+    if (new_num_outputs != old_num_outputs)
+        FatalError("Number of outputs changed on update.\n");
+
+    mir_display_config_release(xmir_screen->display);
+    xmir_screen->display = new_config;
+
+    i = 0;
+    xorg_list_for_each_entry(xmir_output, &xmir_screen->output_list, link) {
+        mir_output = mir_display_config_get_output(new_config, i);
+        xmir_output_update(xmir_output, mir_output);
+        ++i;
+    }
+
+    xmir_output_screen_resized(xmir_screen);
+}
+
+void
+xmir_output_handle_orientation(struct xmir_window *xmir_window,
+                               MirOrientation dir)
+{
+    XMIR_DEBUG(("Orientation: %i\n", dir));
+
+    xmir_output_handle_resize(xmir_window, -1, -1);
+}
+
+void
+xmir_output_handle_resize(struct xmir_window *xmir_window,
+                          int width, int height)
+{
+    WindowPtr window = xmir_window->window;
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    PixmapPtr pixmap;
+    DrawablePtr oldroot = &screen->root->drawable;
+    BoxRec box;
+    BoxRec copy_box;
+
+    int window_width, window_height;
+    DeviceIntPtr pDev;
+
+    MirOrientation old = xmir_window->orientation;
+    xmir_window->orientation = mir_window_get_orientation(xmir_window->surface);
+
+    if (width < 0 && height < 0) {
+        if (old % 180 == xmir_window->orientation % 180) {
+            window_width = window->drawable.width;
+            window_height = window->drawable.height;
+        }
+        else {
+            window_width = window->drawable.height;
+            window_height = window->drawable.width;
+        }
+    }
+    else if (xmir_window->orientation == 0 || xmir_window->orientation == 180) {
+        window_width = width * (1 + xmir_screen->doubled);
+        window_height = height * (1 + xmir_screen->doubled);
+    }
+    else {
+        window_width = height * (1 + xmir_screen->doubled);
+        window_height = width * (1 + xmir_screen->doubled);
+    }
+
+    if (window_width == window->drawable.width &&
+        window_height == window->drawable.height) {
+        /* Damage window if rotated */
+        if (old != xmir_window->orientation)
+            DamageDamageRegion(&window->drawable, &xmir_window->region);
+        return;
+    }
+
+    /* In case of async EGL, destroy the image after swap has finished */
+    if (xmir_window->image) {
+        if (!xmir_window->has_free_buffer) {
+            while (1) {
+                xmir_process_from_eventloop();
+                if (xmir_window->has_free_buffer)
+                    break;
+                usleep(1000);
+            }
+        }
+
+        eglDestroyImageKHR(xmir_screen->egl_display, xmir_window->image);
+        xmir_window->image = NULL;
+    }
+
+    if (xmir_screen->rootless)
+        return;
+
+    if (!xmir_screen->windowed) {
+        XMIR_DEBUG(("Root resized, removing all outputs and inserting fake output\n"));
+
+        while (!xorg_list_is_empty(&xmir_screen->output_list)) {
+            struct xmir_output *xmir_output;
+
+            xmir_output = xorg_list_first_entry(&xmir_screen->output_list,
+                                                typeof(*xmir_output),
+                                                link);
+
+            RRCrtcDestroy(xmir_output->randr_crtc);
+            RROutputDestroy(xmir_output->randr_output);
+            xmir_output_destroy(xmir_output);
+        }
+
+        xmir_screen->windowed = xmir_output_create(xmir_screen, "Windowed");
+        xmir_disable_screensaver(xmir_screen);
+    }
+
+    XMIR_DEBUG(("Output resized %ix%i with rotation %i\n",
+                width, height, xmir_window->orientation));
+
+    pixmap = screen->CreatePixmap(screen,
+                                  window_width, window_height,
+                                  screen->rootDepth,
+                                  CREATE_PIXMAP_USAGE_BACKING_PIXMAP);
+
+    copy_box.x1 = copy_box.y1 = 0;
+    copy_box.x2 = min(window_width, oldroot->width);
+    copy_box.y2 = min(window_height, oldroot->height);
+
+    if (xmir_screen->glamor) {
+        glamor_pixmap_private *pixmap_priv = glamor_get_pixmap_private(pixmap);
+        glBindFramebuffer(GL_FRAMEBUFFER, pixmap_priv->fbo->fb);
+        glClearColor(0., 0., 0., 1.);
+        glClear(GL_COLOR_BUFFER_BIT);
+        glamor_copy(&screen->root->drawable, &pixmap->drawable,
+                              NULL, &copy_box, 1, 0, 0, FALSE, FALSE, 0, NULL);
+        glBindFramebuffer(GL_FRAMEBUFFER, 0);
+    }
+    else {
+        PixmapPtr old_pixmap = screen->GetWindowPixmap(window);
+        int src_stride = old_pixmap->devKind;
+        int dst_stride = pixmap->devKind;
+        int bpp = oldroot->bitsPerPixel >> 3;
+        const char *src = (char*)old_pixmap->devPrivate.ptr +
+                          src_stride * copy_box.y1 +
+                          copy_box.x1 * bpp;
+        char *dst = (char*)pixmap->devPrivate.ptr +
+                    dst_stride * copy_box.y1 +
+                    copy_box.x1 * bpp;
+        int line_len = (copy_box.x2 - copy_box.x1) * bpp;
+        int y;
+        for (y = copy_box.y1; y < copy_box.y2; ++y) {
+            memcpy(dst, src, line_len);
+            memset(dst+line_len, 0, dst_stride-line_len);
+            src += src_stride;
+            dst += dst_stride;
+        }
+        if (y < window_height)
+            memset(dst, 0, (window_height - y) * dst_stride);
+    }
+
+    screen->width = window_width;
+    screen->height = window_height;
+    screen->mmWidth = screen->width * 254 / (10 * xmir_screen->dpi);
+    screen->mmHeight = screen->height * 254 / (10 * xmir_screen->dpi);
+
+    screen->SetScreenPixmap(pixmap);
+
+    SetRootClip(screen, ROOT_CLIP_FULL);
+
+    box.x1 = box.y1 = 0;
+    box.x2 = window_width;
+    box.y2 = window_height;
+    RegionReset(&xmir_window->region, &box);
+    DamageDamageRegion(&window->drawable, &xmir_window->region);
+
+    /* Update cursor info too */
+    for (pDev = inputInfo.devices; pDev; pDev = pDev->next) {
+        int x, y;
+
+        if (!IsPointerDevice(pDev))
+            continue;
+
+        miPointerGetPosition(pDev, &x, &y);
+        UpdateSpriteForScreen(pDev, screen);
+        miPointerSetScreen(pDev, 0, x, y);
+    }
+
+    xmir_screen_update_windowed_output(xmir_screen);
+    if (ConnectionInfo)
+        RRScreenSizeNotify(xmir_screen->screen);
+    update_desktop_dimensions();
+}
+
+static void
+xmir_handle_hotplug(struct xmir_screen *xmir_screen,
+                    struct xmir_window *unused1,
+                    void *unused2)
+{
+    xmir_update_config(xmir_screen);
+
+    /* Trigger RANDR refresh */
+    RRGetInfo(screenInfo.screens[0], TRUE);
+}
+
+static void
+xmir_display_config_callback(MirConnection *conn, void *ctx)
+{
+    struct xmir_screen *xmir_screen = ctx;
+    xmir_post_to_eventloop(xmir_handle_hotplug, xmir_screen, 0, 0);
+}
+
+Bool
+xmir_screen_init_output(struct xmir_screen *xmir_screen)
+{
+    rrScrPrivPtr rp;
+    int i;
+    MirDisplayConfig *display_config = xmir_screen->display;
+    int num_outputs;
+    int output_type_count[mir_display_output_type_edp + 1] = {};
+
+    if (!RRScreenInit(xmir_screen->screen))
+        return FALSE;
+
+    mir_connection_set_display_config_change_callback(xmir_screen->conn,
+                                                      &xmir_display_config_callback,
+                                                      xmir_screen);
+
+    num_outputs = mir_display_config_get_num_outputs(display_config);
+    for (i = 0; i < num_outputs; i++) {
+        char name[32];
+        int type_count;
+        MirOutput const *mir_output;
+        MirOutputType output_type;
+        const char* output_type_str;
+        struct xmir_output *xmir_output;
+
+        mir_output = mir_display_config_get_output(display_config, i);
+        output_type = mir_output_get_type(mir_output);
+        output_type_str = mir_output_type_name(output_type);
+        if (output_type_str)
+            type_count = output_type_count[output_type]++;
+        snprintf(name, sizeof name, "%s-%d", output_type_str, type_count);
+
+        xmir_output = xmir_output_create(xmir_screen, name);
+        if (!xmir_output)
+            return FALSE;
+        xmir_output_update(xmir_output, mir_output);
+    }
+
+    RRScreenSetSizeRange(xmir_screen->screen, 320, 200, INT16_MAX, INT16_MAX);
+
+    xmir_output_screen_resized(xmir_screen);
+
+    rp = rrGetScrPriv(xmir_screen->screen);
+    rp->rrGetInfo = xmir_randr_get_info;
+    rp->rrSetConfig = xmir_randr_set_config;
+    // TODO: rp->rrCrtcSet = xmir_randr_set_crtc;
+
+    return TRUE;
+}
--- /dev/null
+++ b/hw/xmir/xmir-thread-proxy.c
@@ -0,0 +1,110 @@
+/*
+ * Copyright © 2012-2017 Canonical Ltd
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Christopher James Halse Rogers (christopher.halse.rogers@canonical.com)
+ * Later rewritten, simplified and optimized by:
+ *   Daniel van Vugt <daniel.van.vugt@canonical.com>
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#include "xmir.h"
+
+struct message {
+    xmir_event_callback *callback;
+    struct xmir_screen *xmir_screen;
+    struct xmir_window *xmir_window;
+    void *arg;
+};
+
+static int pipefds[2];
+
+static void
+xmir_socket_ready(int fd, int ready, void *data)
+{
+    xmir_process_from_eventloop();
+}
+
+void
+xmir_init_thread_to_eventloop(void)
+{
+    int err = pipe(pipefds);
+    if (err == -1)
+        FatalError("[XMIR] Failed to create thread-proxy pipes: %s\n",
+                   strerror(errno));
+
+    /* Set the read end to not block; we'll pull from this in the event loop
+     * We don't need to care about the write end, as that'll be written to
+     * from its own thread
+     */
+    fcntl(pipefds[0], F_SETFL, O_NONBLOCK);
+
+    SetNotifyFd(pipefds[0], xmir_socket_ready, X_NOTIFY_READ, NULL);
+}
+
+void
+xmir_fini_thread_to_eventloop(void)
+{
+    RemoveNotifyFd(pipefds[0]);
+    close(pipefds[1]);
+    close(pipefds[0]);
+}
+
+void
+xmir_post_to_eventloop(xmir_event_callback *cb,
+                       struct xmir_screen *s, struct xmir_window *w, void *a)
+{
+    struct message msg = {cb, s, w, a};
+    ssize_t written = write(pipefds[1], &msg, sizeof msg);
+    if (written != sizeof(msg))
+        ErrorF("[XMIR] Failed to proxy message to mainloop\n");
+}
+
+void
+xmir_process_from_eventloop_except(const struct xmir_window *w)
+{
+    for (;;) {
+        struct message msg;
+        ssize_t got = read(pipefds[0], &msg, sizeof msg);
+        if (got < 0)
+            return;
+        if (got == sizeof(msg) && w != msg.xmir_window)
+            msg.callback(msg.xmir_screen, msg.xmir_window, msg.arg);
+    }
+}
+
+void
+xmir_process_from_eventloop(void)
+{
+    xmir_process_from_eventloop_except(NULL);
+}
--- /dev/null
+++ b/hw/xmir/xmir.c
@@ -0,0 +1,1818 @@
+/*
+ * Copyright © 2015-2017 Canonical Ltd
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+#include "xf86.h"
+
+#include "xmir.h"
+
+#include <stdio.h>
+#include <signal.h>
+#include <dlfcn.h>
+
+#include <selection.h>
+#include <micmap.h>
+#include <misyncshm.h>
+#include <glx_extinit.h>
+#include <X11/Xatom.h>
+
+#include <mir_toolkit/version.h>
+#include <mir_toolkit/mir_surface.h>
+
+#include "compint.h"
+#include "dri2.h"
+#include "glxserver.h"
+#include "glamor_priv.h"
+#include "dpmsproc.h"
+
+static struct {
+    Atom UTF8_STRING;
+    Atom _NET_WM_NAME;
+    Atom WM_PROTOCOLS;
+    Atom WM_DELETE_WINDOW;
+    Atom _NET_WM_WINDOW_TYPE;
+    Atom _NET_WM_WINDOW_TYPE_DESKTOP;
+    Atom _NET_WM_WINDOW_TYPE_DOCK;
+    Atom _NET_WM_WINDOW_TYPE_TOOLBAR;
+    Atom _NET_WM_WINDOW_TYPE_MENU;
+    Atom _NET_WM_WINDOW_TYPE_UTILITY;
+    Atom _NET_WM_WINDOW_TYPE_SPLASH;
+    Atom _NET_WM_WINDOW_TYPE_DIALOG;
+    Atom _NET_WM_WINDOW_TYPE_DROPDOWN_MENU;
+    Atom _NET_WM_WINDOW_TYPE_POPUP_MENU;
+    Atom _NET_WM_WINDOW_TYPE_TOOLTIP;
+    Atom _NET_WM_WINDOW_TYPE_NOTIFICATION;
+    Atom _NET_WM_WINDOW_TYPE_COMBO;
+    Atom _NET_WM_WINDOW_TYPE_DND;
+    Atom _NET_WM_WINDOW_TYPE_NORMAL;
+    Atom _MIR_WM_PERSISTENT_ID;
+} known_atom;
+
+static Atom get_atom(const char *name, Atom *cache, Bool create)
+{
+    if (!*cache) {
+        *cache = MakeAtom(name, strlen(name), create);
+        if (*cache)
+            XMIR_DEBUG(("Atom %s = %lu\n", name, (unsigned long)*cache));
+    }
+    return *cache;
+}
+
+#define GET_ATOM(_a)  get_atom(#_a, &known_atom._a, FALSE)
+#define MAKE_ATOM(_a) get_atom(#_a, &known_atom._a, TRUE)
+
+extern __GLXprovider __glXDRI2Provider;
+
+Bool xmir_debug_logging = FALSE;
+
+static const char get_title_from_top_window[] = "@";
+
+struct xmir_swap {
+    int server_generation;
+    struct xmir_screen *xmir_screen;
+    struct xmir_window *xmir_window;
+};
+
+static void xmir_handle_buffer_received(MirBufferStream *stream, void *ctx);
+
+/* Required by GLX module */
+ScreenPtr xf86ScrnToScreen(ScrnInfoPtr pScrn)
+{
+    return NULL;
+}
+
+/* Required by GLX module */
+ScrnInfoPtr xf86ScreenToScrn(ScreenPtr pScreen)
+{
+    static ScrnInfoRec rec;
+    return &rec;
+}
+
+/* Required by GLX module */
+void
+xf86ProcessOptions(int scrnIndex, XF86OptionPtr options, OptionInfoPtr optinfo)
+{
+}
+
+/* Required by GLX module */
+const char *
+xf86GetOptValString(const OptionInfoRec *table, int token)
+{
+    /* This may bite us in the bum since it sends up hardcoding "mesa" as the GL
+     * vendor, but... */
+    return NULL;
+}
+
+void
+ddxGiveUp(enum ExitCode error)
+{
+}
+
+void
+AbortDDX(enum ExitCode error)
+{
+    ddxGiveUp(error);
+}
+
+void
+OsVendorInit(void)
+{
+}
+
+void
+OsVendorFatalError(const char *f, va_list args)
+{
+}
+
+#if defined(DDXBEFORERESET)
+void
+ddxBeforeReset(void)
+{
+    return;
+}
+#endif
+
+void
+ddxUseMsg(void)
+{
+    ErrorF("-rootless              Run rootless\n");
+    ErrorF("  -flatten             Flatten rootless X windows into a single surface\n");
+    ErrorF("    -neverclose        Never close the flattened rootless window\n");
+    ErrorF("-title <name>          Set window title (@ = automatic)\n");
+    ErrorF("-sw                    disable glamor rendering\n");
+    ErrorF("-egl                   force use of EGL calls, disables DRI2 pass-through\n");
+    ErrorF("-egl_sync              same as -egl, but with synchronous page flips.\n");
+    ErrorF("-damage                copy the entire frame on damage, always enabled in egl mode\n");
+    ErrorF("-fd <num>              force client connection on only fd\n");
+    ErrorF("-shared                open default listening sockets even when -fd is passed\n");
+    ErrorF("-mir <appid>           set mir's application id.\n");
+    ErrorF("-mirSocket <socket>    use the specified socket for mir\n");
+    ErrorF("-2x                    double the fun (2x resolution compared to onscreen)\n");
+    ErrorF("-debug                 Log everything Xmir is doing\n");
+}
+
+int
+ddxProcessArgument(int argc, char *argv[], int i)
+{
+    static int seen_shared;
+
+    if (strcmp(argv[i], "-rootless") == 0 ||
+        strcmp(argv[i], "-flatten") == 0 ||
+        strcmp(argv[i], "-neverclose") == 0 ||
+        strcmp(argv[i], "-sw") == 0 ||
+        strcmp(argv[i], "-egl") == 0 ||
+        strcmp(argv[i], "-egl_sync") == 0 ||
+        strcmp(argv[i], "-2x") == 0 ||
+        strcmp(argv[i], "-debug") == 0 ||
+        strcmp(argv[i], "-damage") == 0) {
+        return 1;
+    }
+    else if (strcmp(argv[i], "-mirSocket") == 0 ||
+             strcmp(argv[i], "-title") == 0 ||
+             strcmp(argv[i], "-mir") == 0) {
+        return 2;
+    }
+    else if (!strcmp(argv[i], "-novtswitch") ||
+               !strncmp(argv[i], "vt", 2)) {
+        return 1;
+    /* Bypass unity8 "security" */
+    }
+    else if (!strncmp(argv[i], "--desktop_file_hint=", strlen("--desktop_file_hint="))) {
+        return 1;
+    }
+    else if (!strcmp(argv[i], "-fd")) {
+        if (!seen_shared)
+            NoListenAll = 1;
+
+        return 2;
+    }
+    else if (!strcmp(argv[i], "-shared")) {
+        seen_shared = 1;
+        NoListenAll = 0;
+        return 1;
+    }
+    else if (!strcmp(argv[i], "-listen")) {
+        seen_shared = 1;
+        NoListenAll = 0;
+        return 0;
+    }
+
+    return 0;
+}
+
+static DevPrivateKeyRec xmir_window_private_key;
+static DevPrivateKeyRec xmir_screen_private_key;
+static DevPrivateKeyRec xmir_pixmap_private_key;
+
+struct xmir_screen *
+xmir_screen_get(ScreenPtr screen)
+{
+    return dixLookupPrivate(&screen->devPrivates, &xmir_screen_private_key);
+}
+
+struct xmir_pixmap *
+xmir_pixmap_get(PixmapPtr pixmap)
+{
+    return dixLookupPrivate(&pixmap->devPrivates, &xmir_pixmap_private_key);
+}
+
+struct xmir_window *
+xmir_window_get(WindowPtr window)
+{
+    return dixLookupPrivate(&window->devPrivates, &xmir_window_private_key);
+}
+
+void
+xmir_pixmap_set(PixmapPtr pixmap, struct xmir_pixmap *xmir_pixmap)
+{
+    return dixSetPrivate(&pixmap->devPrivates,
+                         &xmir_pixmap_private_key,
+                         xmir_pixmap);
+}
+
+static Bool
+xmir_get_window_prop_string8(WindowPtr window, ATOM atom,
+                             char *buf, size_t bufsize)
+{
+    if (window->optional) {
+        PropertyPtr p = window->optional->userProps;
+        while (p) {
+            if (p->propertyName == atom) {
+                if ((  p->type == XA_STRING
+                    || p->type == GET_ATOM(UTF8_STRING)
+                    ) &&
+                    p->format == 8 && p->data) {
+                    size_t len = p->size >= bufsize ? bufsize - 1 : p->size;
+                    memcpy(buf, p->data, len);
+                    buf[len] = '\0';
+                    return TRUE;
+                }
+                else {
+                    ErrorF("xmir_get_window_prop_string8: Atom %d is not "
+                           "an 8-bit string as expected\n", atom);
+                    break;
+                }
+            }
+            p = p->next;
+        }
+    }
+
+    if (bufsize)
+        buf[0] = '\0';
+    return FALSE;
+}
+
+static Bool
+xmir_get_window_name(WindowPtr window, char *buf, size_t bufsize)
+{
+    return xmir_get_window_prop_string8(window, GET_ATOM(_NET_WM_NAME),
+                                        buf, bufsize)
+        || xmir_get_window_prop_string8(window, XA_WM_NAME, buf, bufsize);
+}
+
+static WindowPtr
+xmir_get_window_prop_window(WindowPtr window, ATOM atom)
+{
+    if (window->optional) {
+        PropertyPtr p = window->optional->userProps;
+        while (p) {
+            if (p->propertyName == atom) {
+                if (p->type == XA_WINDOW) {
+                    WindowPtr ptr;
+                    XID id = *(XID*)p->data;
+                    if (dixLookupWindow(&ptr, id, serverClient,
+                                        DixReadAccess) != Success)
+                        ptr = NULL;
+                    return ptr;
+                }
+                else {
+                    ErrorF("xmir_get_window_prop_window: Atom %d is not "
+                           "a Window as expected\n", atom);
+                    return NULL;
+                }
+            }
+            p = p->next;
+        }
+    }
+    return NULL;
+}
+
+static Atom
+xmir_get_window_prop_atom(WindowPtr window, ATOM name)
+{
+    if (window->optional) {
+        PropertyPtr p = window->optional->userProps;
+        while (p) {
+            if (p->propertyName == name) {
+                if (p->type == XA_ATOM) {
+                    return *(Atom*)p->data;
+                }
+                else {
+                    ErrorF("xmir_get_window_prop_atom: Atom %d is not "
+                           "an Atom as expected\n", name);
+                    return 0;
+                }
+            }
+            p = p->next;
+        }
+    }
+    return 0;
+}
+
+enum XWMHints_flag {
+    InputHint = 1
+    /* There are more but not yet required */
+};
+
+typedef struct {
+    long flags;     /* marks which fields in this structure are defined */
+    Bool input;     /* does this application rely on the window manager to
+                       get keyboard input? */
+    int initial_state;      /* see below */
+    Pixmap icon_pixmap;     /* pixmap to be used as icon */
+    Window icon_window;     /* window to be used as icon */
+    int icon_x, icon_y;     /* initial position of icon */
+    Pixmap icon_mask;       /* icon mask bitmap */
+    XID window_group;       /* id of related window group */
+    /* this structure may be extended in the future */
+} XWMHints;
+
+static XWMHints*
+xmir_get_window_prop_hints(WindowPtr window)
+{
+    if (window->optional) {
+        PropertyPtr p = window->optional->userProps;
+        while (p) {
+            if (p->propertyName == XA_WM_HINTS)
+                return (XWMHints*)p->data;
+            p = p->next;
+        }
+    }
+    return NULL;
+}
+
+static void
+damage_report(DamagePtr pDamage, RegionPtr pRegion, void *data)
+{
+    struct xmir_window *xmir_window = data;
+    struct xmir_screen *xmir_screen = xmir_window->xmir_screen;
+
+    xorg_list_add(&xmir_window->link_damage, &xmir_screen->damage_window_list);
+}
+
+static void
+damage_destroy(DamagePtr pDamage, void *data)
+{
+}
+
+static void
+xmir_window_enable_damage_tracking(struct xmir_window *xmir_win)
+{
+    WindowPtr win = xmir_win->window;
+
+    if (xmir_win->damage != NULL)
+        return;
+
+    xmir_win->damage = DamageCreate(damage_report, damage_destroy,
+                                    DamageReportNonEmpty, FALSE,
+                                    win->drawable.pScreen, xmir_win);
+    DamageRegister(&win->drawable, xmir_win->damage);
+    DamageSetReportAfterOp(xmir_win->damage, TRUE);
+}
+
+static void
+xmir_window_disable_damage_tracking(struct xmir_window *xmir_win)
+{
+    if (xmir_win->damage != NULL) {
+        DamageUnregister(xmir_win->damage);
+        DamageDestroy(xmir_win->damage);
+        xmir_win->damage = NULL;
+    }
+}
+
+static void
+xmir_sw_copy(struct xmir_screen *xmir_screen,
+             struct xmir_window *xmir_win,
+             RegionPtr dirty)
+{
+    PixmapPtr pix = xmir_screen->screen->GetWindowPixmap(xmir_win->window);
+    int x1 = dirty->extents.x1, y1 = dirty->extents.y1;
+    int x2 = dirty->extents.x2, y2 = dirty->extents.y2;
+    int y, line_len, src_stride = pix->devKind;
+    int bpp = pix->drawable.bitsPerPixel >> 3;
+    char *src, *dst;
+    MirGraphicsRegion region;
+
+    mir_buffer_stream_get_graphics_region(
+        mir_window_get_buffer_stream(xmir_win->surface), &region);
+
+    /*
+     * Our window region (and hence damage region) might be a little ahead of
+     * the current buffer in terms of size, during a resize. So we must accept
+     * that their dimensions might not match and take the safe intersection...
+     */
+    if (x1 < 0) x1 = 0;
+    if (y1 < 0) y1 = 0;
+    if (x2 > region.width) x2 = region.width;
+    if (y2 > region.height) y2 = region.height;
+    if (x2 > pix->drawable.width) x2 = pix->drawable.width;
+    if (y2 > pix->drawable.height) y2 = pix->drawable.height;
+    if (x2 <= x1 || y2 <= y1) return;
+
+    src = (char*)pix->devPrivate.ptr + src_stride*y1 + x1*bpp;
+    dst = region.vaddr + y1*region.stride + x1*bpp;
+
+    line_len = (x2 - x1) * bpp;
+    for (y = y1; y < y2; ++y) {
+        memcpy(dst, src, line_len);
+        if (x2 < region.width)
+            memset(dst+x2*bpp, 0, (region.width - x2)*bpp);
+        src += src_stride;
+        dst += region.stride;
+    }
+
+    if (y2 < region.height)
+        memset(dst, 0, (region.height - y2)*region.stride);
+}
+
+static void
+xmir_get_current_buffer_dimensions(
+    struct xmir_screen *xmir_screen, struct xmir_window *xmir_win,
+    int *width, int *height)
+{
+    MirBufferPackage *package;
+    MirGraphicsRegion reg;
+    MirBufferStream *stream = mir_window_get_buffer_stream(xmir_win->surface);
+
+    switch (xmir_screen->glamor) {
+    case glamor_off:
+        mir_buffer_stream_get_graphics_region(stream, &reg);
+        *width = reg.width;
+        *height = reg.height;
+        break;
+    case glamor_dri:
+        mir_buffer_stream_get_current_buffer(stream, &package);
+        *width = package->width;
+        *height = package->height;
+        break;
+    case glamor_egl:
+    case glamor_egl_sync:
+        eglQuerySurface(xmir_screen->egl_display, xmir_win->egl_surface,
+                        EGL_WIDTH, width);
+        eglQuerySurface(xmir_screen->egl_display, xmir_win->egl_surface,
+                        EGL_HEIGHT, height);
+        break;
+    default:
+        break;
+    }
+}
+
+static void
+xmir_swap(struct xmir_screen *xmir_screen, struct xmir_window *xmir_win)
+{
+    MirBufferStream *stream = mir_window_get_buffer_stream(xmir_win->surface);
+    struct xmir_swap *swap = calloc(sizeof(struct xmir_swap), 1);
+    swap->server_generation = serverGeneration;
+    swap->xmir_screen = xmir_screen;
+    swap->xmir_window = xmir_win;
+    mir_buffer_stream_swap_buffers(stream, xmir_handle_buffer_received, swap);
+}
+
+void xmir_repaint(struct xmir_window *xmir_win)
+{
+    struct xmir_screen *xmir_screen;
+    RegionPtr dirty = &xmir_win->region;
+    char wm_name[256];
+    WindowPtr named = NULL;
+
+    if (!xmir_win->has_free_buffer)
+        ErrorF("ERROR: xmir_repaint requested without a buffer to paint to\n");
+
+    xmir_screen = xmir_screen_get(xmir_win->window->drawable.pScreen);
+    if (strcmp(xmir_screen->title, get_title_from_top_window)) {
+        /* Fixed title mode. Never change it. */
+        named = NULL;
+    }
+    else if (xmir_screen->rootless) {
+        named = xmir_win->window;
+    }
+    else { /* Try and guess from the most relevant app window */
+        WindowPtr top = xmir_screen->screen->root->firstChild;
+        WindowPtr top_named = NULL;
+        WindowPtr top_normal = NULL;
+
+        while (top) {
+            Atom wm_type;
+            WindowPtr app_window;
+            if (!top->viewable) {
+                top = top->nextSib;
+                continue;
+            }
+            app_window = xmir_get_window_prop_window(top, XA_WM_TRANSIENT_FOR);
+            if (app_window) {
+                named = app_window;
+                break;
+            }
+            wm_type = xmir_get_window_prop_atom(top,
+                                               GET_ATOM(_NET_WM_WINDOW_TYPE));
+            if (wm_type && wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_NORMAL))
+                top_normal = top;
+            if (xmir_get_window_name(top, wm_name, sizeof wm_name))
+                top_named = top;
+
+            top = top->firstChild;
+        }
+        if (!named)
+            named = top_normal ? top_normal : top_named;
+    }
+
+    if (named &&
+        xmir_get_window_name(named, wm_name, sizeof wm_name) &&
+        strcmp(wm_name, xmir_win->wm_name)) {
+        MirWindowSpec *rename =
+            mir_create_window_spec(xmir_screen->conn);
+        mir_window_spec_set_name(rename, wm_name);
+        mir_window_apply_spec(xmir_win->surface, rename);
+        mir_window_spec_release(rename);
+        strncpy(xmir_win->wm_name, wm_name, sizeof(xmir_win->wm_name));
+    }
+
+    switch (xmir_screen->glamor) {
+    case glamor_off:
+        xmir_sw_copy(xmir_screen, xmir_win, dirty);
+        xmir_win->has_free_buffer = FALSE;
+        xmir_swap(xmir_screen, xmir_win);
+        break;
+    case glamor_dri:
+        xmir_glamor_copy(xmir_screen, xmir_win, dirty);
+        xmir_win->has_free_buffer = FALSE;
+        xmir_swap(xmir_screen, xmir_win);
+        break;
+    case glamor_egl:
+    case glamor_egl_sync:
+        xmir_glamor_copy(xmir_screen, xmir_win, dirty);
+        xmir_win->has_free_buffer = TRUE;
+        /* Will eglSwapBuffers (?) */
+        break;
+    default:
+        break;
+    }
+
+    DamageEmpty(xmir_win->damage);
+    xorg_list_del(&xmir_win->link_damage);
+}
+
+void
+xmir_handle_buffer_available(struct xmir_screen *xmir_screen,
+                             struct xmir_window *xmir_win,
+                             void *unused)
+{
+    int buf_width, buf_height;
+    Bool xserver_lagging, xclient_lagging;
+
+    if (!xmir_win->damage || !mir_window_is_valid(xmir_win->surface)) {
+        if (xmir_win->damage)
+            ErrorF("Buffer-available recieved for invalid surface?\n");
+        return;
+    }
+
+    DebugF("Buffer-available on %p\n", xmir_win);
+    xmir_get_current_buffer_dimensions(xmir_screen, xmir_win,
+                                       &buf_width, &buf_height);
+
+    xmir_win->has_free_buffer = TRUE;
+    xmir_win->buf_width = buf_width;
+    xmir_win->buf_height = buf_height;
+
+    xserver_lagging = buf_width != xmir_win->surface_width ||
+                      buf_height != xmir_win->surface_height;
+
+    xclient_lagging = buf_width != xmir_win->window->drawable.width ||
+                      buf_height != xmir_win->window->drawable.height;
+
+    if (xserver_lagging || !xorg_list_is_empty(&xmir_win->link_damage))
+        xmir_repaint(xmir_win);
+
+    if (xclient_lagging) {
+        if (xmir_screen->rootless) {
+            XID vlist[2] = {buf_width, buf_height};
+            ConfigureWindow(xmir_win->window, CWWidth|CWHeight, vlist,
+                            serverClient);
+        }
+        else {
+            /* Output resizing takes time, so start it going and let it
+             * finish next frame or so...
+             */
+            xmir_output_handle_resize(xmir_win, buf_width, buf_height);
+        }
+    }
+
+    if (xserver_lagging)
+        DamageDamageRegion(&xmir_win->window->drawable, &xmir_win->region);
+}
+
+static void
+xmir_handle_buffer_received(MirBufferStream *stream, void *ctx)
+{
+    struct xmir_swap *swap = ctx;
+    struct xmir_screen *xmir_screen = swap->xmir_screen;
+
+    if (swap->server_generation == serverGeneration && !xmir_screen->closing) {
+        xmir_post_to_eventloop(xmir_handle_buffer_available, xmir_screen,
+                               swap->xmir_window, 0);
+    }
+
+    free(swap);
+}
+
+static Bool
+xmir_create_window(WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    struct xmir_window *xmir_window = calloc(sizeof(*xmir_window), 1);
+    Bool ret;
+
+    if (!xmir_window)
+        return FALSE;
+
+    xmir_window->xmir_screen = xmir_screen;
+    xmir_window->window = window;
+    xorg_list_init(&xmir_window->link_damage);
+    xorg_list_init(&xmir_window->flip.entry);
+    xorg_list_init(&xmir_window->link_flattened);
+
+    screen->CreateWindow = xmir_screen->CreateWindow;
+    ret = (*screen->CreateWindow) (window);
+    xmir_screen->CreateWindow = screen->CreateWindow;
+    screen->CreateWindow = xmir_create_window;
+
+    if (ret)
+        dixSetPrivate(&window->devPrivates,
+                      &xmir_window_private_key,
+                      xmir_window);
+    else
+        free(xmir_window);
+
+    return ret;
+}
+
+static void
+xmir_window_update_region(struct xmir_window *xmir_window)
+{
+    WindowPtr window = xmir_window->window;
+    BoxRec box = {0, 0, window->drawable.width, window->drawable.height};
+    RegionReset(&xmir_window->region, &box);
+}
+
+static Bool
+xmir_realize_window(WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    struct xmir_window *xmir_window = xmir_window_get(window);
+    Bool ret;
+    MirPixelFormat pixel_format = mir_pixel_format_invalid;
+    Atom wm_type = 0;
+    int mir_width = window->drawable.width / (1 + xmir_screen->doubled);
+    int mir_height = window->drawable.height / (1 + xmir_screen->doubled);
+    MirWindowSpec* spec = NULL;
+    WindowPtr wm_transient_for = NULL, positioning_parent = NULL;
+    MirWindowId *persistent_id = NULL;
+    XWMHints *wm_hints = NULL;
+    char wm_name[1024];
+
+    screen->RealizeWindow = xmir_screen->RealizeWindow;
+    ret = (*screen->RealizeWindow) (window);
+    xmir_screen->RealizeWindow = screen->RealizeWindow;
+    screen->RealizeWindow = xmir_realize_window;
+
+    if (xmir_screen->rootless && !window->parent) {
+        RegionNull(&window->clipList);
+        RegionNull(&window->borderClip);
+        RegionNull(&window->winSize);
+    }
+    xmir_window_update_region(xmir_window);
+
+    xmir_get_window_name(window, wm_name, sizeof wm_name);
+    wm_type = xmir_get_window_prop_atom(window, GET_ATOM(_NET_WM_WINDOW_TYPE));
+    wm_transient_for = xmir_get_window_prop_window(window, XA_WM_TRANSIENT_FOR);
+
+    XMIR_DEBUG(("Realize %swindow %p id=0x%x \"%s\": %dx%d %+d%+d parent=%p\n"
+           "\tdepth=%d redir=%u type=%hu class=%u visibility=%u viewable=%u\n"
+           "\toverride=%d _NET_WM_WINDOW_TYPE=%lu(%s)\n"
+           "\tWM_TRANSIENT_FOR=%p\n",
+           window == screen->root ? "ROOT " : "",
+           window, (int)window->drawable.id, wm_name, mir_width, mir_height,
+           window->drawable.x, window->drawable.y,
+           window->parent,
+           window->drawable.depth,
+           window->redirectDraw, window->drawable.type,
+           window->drawable.class, window->visibility, window->viewable,
+           window->overrideRedirect,
+           (unsigned long)wm_type, NameForAtom(wm_type)?:"",
+           wm_transient_for));
+
+    wm_hints = xmir_get_window_prop_hints(window);
+    if (wm_hints) {
+        XMIR_DEBUG(("\tWM_HINTS={flags=0x%lx,input=%s}\n",
+                    wm_hints->flags, wm_hints->input?"True":"False"));
+    }
+    else {
+        XMIR_DEBUG(("\tWM_HINTS=<none>\n"));
+    }
+
+    if (!window->viewable) {
+        return ret;
+    }
+    else if (xmir_screen->rootless) {
+        if (!window->parent || window->parent == screen->root) {
+            compRedirectWindow(serverClient, window,
+                               CompositeRedirectManual);
+            compRedirectSubwindows(serverClient, window,
+                                   CompositeRedirectAutomatic);
+        }
+        if (window->redirectDraw != RedirectDrawManual)
+            return ret;
+    }
+    else if (window->parent) {
+        return ret;
+    }
+
+    if (window->drawable.depth == 32)
+        pixel_format = xmir_screen->depth32_pixel_format;
+    else if (window->drawable.depth == 24)
+        pixel_format = xmir_screen->depth24_pixel_format;
+    else {
+        ErrorF("No pixel format available for depth %d\n",
+               (int)window->drawable.depth);
+        return FALSE;
+    }
+
+    /* TODO: Replace pixel_format with the actual right answer from the
+     *       graphics driver when using EGL:
+     *         mir_connection_get_egl_pixel_format()
+     */
+
+    if (!wm_type)   /* Avoid spurious matches with undetected types */
+        wm_type = -1;
+
+    positioning_parent = wm_transient_for;
+    if (!positioning_parent) {
+        /* The toolkit has not provided a definite positioning parent so the
+         * next best option is to guess. But we can only reasonably guess for
+         * window types that are typically subordinate to normal windows...
+         */
+        Bool is_subordinate = wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_DROPDOWN_MENU)
+                           || wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_POPUP_MENU)
+                           || wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_MENU)
+                           || wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_COMBO)
+                           || wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_TOOLBAR)
+                           || wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_UTILITY)
+                           || wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_TOOLTIP)
+                           || (wm_type == -1 && window->overrideRedirect);
+
+        if (is_subordinate)
+            positioning_parent = xmir_screen->last_focus;
+    }
+
+    if (xmir_screen->flatten && xmir_screen->flatten_top) {
+        WindowPtr top = xmir_screen->flatten_top->window;
+        int dx = window->drawable.x - top->drawable.x;
+        int dy = window->drawable.y - top->drawable.y;
+        xorg_list_append(&xmir_window->link_flattened,
+                         &xmir_screen->flattened_list);
+        ReparentWindow(window, top, dx, dy, serverClient);
+        XMIR_DEBUG(("Flattened window %p (reparented under %p %+d%+d)\n",
+                    window, top, dx, dy));
+        /* And thanks to the X Composite extension, window will now be
+         * automatically composited into the existing flatten_top surface
+         * so we retain only a single Mir surface, as Unity8 likes to see.
+         */
+        return ret;
+    }
+
+    if (xmir_screen->neverclosed) {
+        spec = mir_create_window_spec(xmir_screen->conn);
+    }
+    else if (positioning_parent) {
+        struct xmir_window *rel = xmir_window_get(positioning_parent);
+        if (rel && rel->surface) {
+            short dx = window->drawable.x - rel->window->drawable.x;
+            short dy = window->drawable.y - rel->window->drawable.y;
+            MirRectangle placement = {dx, dy, 0, 0};
+
+            if (wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_TOOLTIP)) {
+                /* Why doesn't the API version match the Mir version?! */
+#if MIR_CLIENT_VERSION >= MIR_VERSION_NUMBER(3,4,0)
+                spec = mir_create_tip_window_spec(
+                    xmir_screen->conn, mir_width, mir_height,
+                    rel->surface, &placement, mir_edge_attachment_any);
+#else
+                spec = mir_connection_create_spec_for_tooltip(
+                    xmir_screen->conn, mir_width, mir_height, pixel_format,
+                    rel->surface, &placement);
+#endif
+            }
+            else if (wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_DIALOG)) {
+                spec = mir_create_modal_dialog_window_spec(
+                    xmir_screen->conn, mir_width, mir_height,
+                    rel->surface);
+            }
+            else {  /* Probably a menu. If not, still close enough... */
+                MirEdgeAttachment edge = mir_edge_attachment_any;
+                if (wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_DROPDOWN_MENU))
+                    edge = mir_edge_attachment_vertical;
+                spec = mir_create_menu_window_spec(
+                    xmir_screen->conn,
+                    mir_width, mir_height, rel->surface,
+                    &placement, edge);
+            }
+        }
+    }
+
+    if (!spec) {
+        if (wm_type == GET_ATOM(_NET_WM_WINDOW_TYPE_DIALOG)) {
+            spec = mir_create_dialog_window_spec(
+                xmir_screen->conn, mir_width, mir_height);
+        }
+        else {
+            spec = mir_create_normal_window_spec(
+                xmir_screen->conn, mir_width, mir_height);
+        }
+    }
+
+    if (strcmp(xmir_screen->title, get_title_from_top_window))
+        mir_window_spec_set_name(spec, xmir_screen->title);
+    else if (xmir_screen->rootless)
+        mir_window_spec_set_name(spec, wm_name);
+
+    xmir_window->surface_width = mir_width;
+    xmir_window->surface_height = mir_height;
+    xmir_window->buf_width = mir_width;
+    xmir_window->buf_height = mir_height;
+
+    mir_window_spec_set_pixel_format(spec, pixel_format);
+    if (xmir_screen->neverclosed) {
+        mir_window_spec_set_width(spec, mir_width);
+        mir_window_spec_set_height(spec, mir_height);
+
+        xmir_window->surface = xmir_screen->neverclosed;
+        mir_window_apply_spec(xmir_window->surface, spec);
+    }
+    else {
+        mir_window_spec_set_buffer_usage(spec,
+                                          xmir_screen->glamor
+                                          ? mir_buffer_usage_hardware
+                                          : mir_buffer_usage_software);
+        xmir_window->surface = mir_create_window_sync(spec);
+    }
+    mir_window_spec_release(spec);
+
+    persistent_id =
+        mir_window_request_window_id_sync(xmir_window->surface);
+    if (mir_window_id_is_valid(persistent_id)) {
+        const char *str = mir_window_id_as_string(persistent_id);
+        dixChangeWindowProperty(serverClient, window,
+                                MAKE_ATOM(_MIR_WM_PERSISTENT_ID),
+                                XA_STRING, 8, PropModeReplace,
+                                strlen(str), (void*)str, FALSE);
+    }
+    mir_window_id_release(persistent_id);
+
+    xmir_window->has_free_buffer = TRUE;
+    if (!mir_window_is_valid(xmir_window->surface)) {
+        ErrorF("failed to create a surface: %s\n",
+               mir_window_get_error_message(xmir_window->surface));
+        return FALSE;
+    }
+    if (!xmir_screen->flatten_top)
+        xmir_screen->flatten_top = xmir_window;
+    mir_window_set_event_handler(xmir_window->surface,
+                                  xmir_surface_handle_event,
+                                  xmir_window);
+
+    xmir_window_enable_damage_tracking(xmir_window);
+
+    if (xmir_screen->glamor)
+        xmir_glamor_realize_window(xmir_screen, xmir_window, window);
+
+    return ret;
+}
+
+static const char *
+xmir_surface_type_str(MirWindowType type)
+{
+    return "unk";
+}
+
+static const char *
+xmir_surface_state_str(MirWindowState state)
+{
+    switch (state) {
+    case mir_surface_state_unknown: return "unknown";
+    case mir_surface_state_restored: return "restored";
+    case mir_surface_state_minimized: return "minimized";
+    case mir_surface_state_maximized: return "maximized";
+    case mir_surface_state_vertmaximized: return "vert maximized";
+    case mir_surface_state_fullscreen: return "fullscreen";
+    default: return "???";
+    }
+}
+
+static const char *
+xmir_surface_focus_str(MirWindowFocusState focus)
+{
+    switch (focus) {
+    case mir_surface_unfocused: return "unfocused";
+    case mir_window_focus_state_focused: return "focused";
+    default: return "???";
+    }
+}
+
+static const char *
+xmir_surface_vis_str(MirWindowVisibility vis)
+{
+    switch (vis) {
+    case mir_surface_visibility_occluded: return "hidden";
+    case mir_surface_visibility_exposed: return "visible";
+    default: return "???";
+    }
+}
+
+static Window
+xmir_get_current_input_focus(DeviceIntPtr kbd)
+{
+    Window id = None;
+    FocusClassPtr focus = kbd->focus;
+    if (focus->win == NoneWin)
+        id = None;
+    else if (focus->win == PointerRootWin)
+        id = PointerRoot;
+    else
+        id = focus->win->drawable.id;
+    return id;
+}
+
+static void
+xmir_handle_focus_event(struct xmir_window *xmir_window,
+                        MirWindowFocusState state)
+{
+    struct xmir_screen *xmir_screen = xmir_window->xmir_screen;
+    DeviceIntPtr keyboard = inputInfo.keyboard; /*PickKeyboard(serverClient);*/
+
+    if (xmir_screen->destroying_root)
+        return;
+
+    if (xmir_window->surface) {  /* It's a real Mir window */
+        xmir_screen->last_focus = (state == mir_window_focus_state_focused) ?
+                                  xmir_window->window : NULL;
+    }
+
+    if (xmir_screen->rootless) {
+        WindowPtr window = xmir_window->window;
+        const XWMHints *hints = xmir_get_window_prop_hints(window);
+        Bool refuse_focus = window->overrideRedirect ||
+            (hints && (hints->flags & InputHint) && !hints->input);
+        if (!refuse_focus) {
+            Window id = (state == mir_window_focus_state_focused) ?
+                        window->drawable.id : None;
+            SetInputFocus(serverClient, keyboard, id, RevertToParent,
+                          CurrentTime, FALSE);
+        }
+    }
+    else if (!strcmp(xmir_screen->title, get_title_from_top_window)) {
+        /*
+         * So as to not break default behaviour, we only hack focus within
+         * the root window when in Unity8 invasive mode (-title @).
+         */
+        Window id = None;
+        if (state == mir_window_focus_state_focused) {
+            id = xmir_screen->saved_focus;
+            if (id == None)
+                id = PointerRoot;
+        }
+        else {
+            xmir_screen->saved_focus = xmir_get_current_input_focus(keyboard);
+            id = None;
+        }
+        SetInputFocus(serverClient, keyboard, id, RevertToNone, CurrentTime,
+                      FALSE);
+    }
+    /* else normal root window mode -- Xmir does not interfere in focus */
+}
+
+void
+xmir_handle_surface_event(struct xmir_window *xmir_window,
+                          MirWindowAttrib attr,
+                          int val)
+{
+    switch (attr) {
+    case mir_surface_attrib_type:
+        XMIR_DEBUG(("Type: %s\n", xmir_surface_type_str(val)));
+        break;
+    case mir_surface_attrib_state:
+        XMIR_DEBUG(("State: %s\n", xmir_surface_state_str(val)));
+        break;
+    case mir_surface_attrib_swapinterval:
+        XMIR_DEBUG(("Swap interval: %i\n", val));
+        break;
+    case mir_surface_attrib_focus:
+        XMIR_DEBUG(("Focus: %s\n", xmir_surface_focus_str(val)));
+        xmir_handle_focus_event(xmir_window, (MirWindowFocusState)val);
+        break;
+    case mir_surface_attrib_dpi:
+        XMIR_DEBUG(("DPI: %i\n", val));
+        break;
+    case mir_surface_attrib_visibility:
+        XMIR_DEBUG(("Visibility: %s\n", xmir_surface_vis_str(val)));
+        break;
+    default:
+        XMIR_DEBUG(("Unhandled attribute %i\n", attr));
+        break;
+    }
+}
+
+void
+xmir_close_surface(struct xmir_window *xmir_window)
+{
+    WindowPtr window = xmir_window->window;
+    struct xmir_screen *xmir_screen = xmir_screen_get(window->drawable.pScreen);
+
+    if (xmir_screen->rootless) {
+        xEvent event;
+        event.u.u.type = ClientMessage;
+        event.u.u.detail = 32;
+        event.u.clientMessage.window = window->drawable.id;
+        event.u.clientMessage.u.l.type = GET_ATOM(WM_PROTOCOLS);
+        event.u.clientMessage.u.l.longs0 = GET_ATOM(WM_DELETE_WINDOW);
+        event.u.clientMessage.u.l.longs1 = CurrentTime;
+        DeliverEvents(window, &event, 1, NullWindow);
+    }
+    else {
+        ErrorF("Root window closed, shutting down Xmir\n");
+        GiveUp(0);
+        /*DeleteWindow(window, 1); ? */
+    }
+}
+
+static void
+xmir_unmap_input(struct xmir_screen *xmir_screen, WindowPtr window)
+{
+    struct xmir_input *xmir_input;
+
+    xorg_list_for_each_entry(xmir_input, &xmir_screen->input_list, link) {
+        if (xmir_input->focus_window &&
+            xmir_input->focus_window->window == window)
+            xmir_input->focus_window = NULL;
+    }
+}
+
+static void
+xmir_bequeath_surface(struct xmir_window *dying, struct xmir_window *benef)
+{
+    struct xmir_screen *xmir_screen = benef->xmir_screen;
+    struct xmir_window *other;
+
+    XMIR_DEBUG(("flatten bequeath: %p --> %p\n",
+                dying->window, benef->window));
+
+    assert(!benef->surface);
+    benef->surface = dying->surface;
+    dying->surface = NULL;
+
+    ReparentWindow(benef->window, xmir_screen->screen->root,
+                   0, 0, serverClient);
+    compRedirectWindow(serverClient, benef->window, CompositeRedirectManual);
+    compRedirectSubwindows(serverClient,
+                           benef->window,
+                           CompositeRedirectAutomatic);
+
+    xorg_list_for_each_entry(other, &xmir_screen->flattened_list,
+                             link_flattened) {
+        ReparentWindow(other->window, benef->window, 0, 0, serverClient);
+    }
+
+    mir_window_set_event_handler(benef->surface, xmir_surface_handle_event,
+                                  benef);
+
+    xmir_window_enable_damage_tracking(benef);
+
+    if (xmir_screen->glamor)
+        xmir_glamor_realize_window(xmir_screen, benef, benef->window);
+}
+
+static void
+xmir_clear_to_black(MirWindow *surface)
+{   /* Admittedly, this will only work for software surfaces */
+    MirBufferStream *stream = mir_window_get_buffer_stream(surface);
+    MirGraphicsRegion region;
+
+    /* On error mir_buffer_stream_get_graphics_region leaves us uninitialized */
+    region.pixel_format = mir_pixel_format_invalid;
+    mir_buffer_stream_get_graphics_region(stream, &region);
+
+    switch (region.pixel_format) {
+        case mir_pixel_format_invalid: return; /* Probably hardware surface */
+        case mir_pixel_format_abgr_8888:
+        case mir_pixel_format_xbgr_8888:
+        case mir_pixel_format_argb_8888:
+        case mir_pixel_format_xrgb_8888: {
+            int y;
+            uint32_t *dest = (uint32_t*)region.vaddr;
+            for (y = 0; y < region.height; ++y) {
+                int x;
+                for (x = 0; x < region.width; ++x)
+                    dest[x] = 0xff000000;
+                dest = (uint32_t*)((char*)dest + region.stride);
+            }
+            break;
+        }
+        case mir_pixel_format_bgr_888:
+        case mir_pixel_format_rgb_888: {
+            int y;
+            char *dest = region.vaddr;
+            for (y = 0; y < region.height; ++y) {
+                memset(dest, 0, region.width*3);
+                dest += region.stride;
+            }
+            break;
+        }
+        case mir_pixel_format_rgb_565:
+        case mir_pixel_format_rgba_5551:
+        case mir_pixel_format_rgba_4444: {
+            uint16_t fill = 0;
+            int y;
+            uint16_t *dest = (uint16_t*)region.vaddr;
+            switch (region.pixel_format) {
+                case mir_pixel_format_rgb_565:   fill = 0x0000; break;
+                case mir_pixel_format_rgba_5551: fill = 0x0001; break;
+                case mir_pixel_format_rgba_4444: fill = 0x000f; break;
+                default: fill = 0;
+            }
+            for (y = 0; y < region.height; ++y) {
+                int x;
+                for (x = 0; x < region.width; ++x)
+                    dest[x] = fill;
+                dest = (uint16_t*)((char*)dest + region.stride);
+            }
+            break;
+        }
+        default:
+            return;
+    }
+    mir_buffer_stream_swap_buffers(stream, NULL, NULL);
+}
+
+static void
+xmir_unmap_surface(struct xmir_screen *xmir_screen,
+                   WindowPtr window,
+                   BOOL destroyed)
+{
+    struct xmir_window *xmir_window =
+        dixLookupPrivate(&window->devPrivates, &xmir_window_private_key);
+
+    if (!xmir_window)
+        return;
+
+    XMIR_DEBUG(("Unmap/unrealize window %p\n", window));
+
+    if (!destroyed)
+        xmir_window_disable_damage_tracking(xmir_window);
+    else
+        xmir_window->damage = NULL;
+
+    xorg_list_del(&xmir_window->link_damage);
+
+    if (xmir_screen->glamor)
+        xmir_glamor_unrealize_window(xmir_screen, xmir_window, window);
+
+    xorg_list_del(&xmir_window->link_flattened);
+
+    if (!xmir_window->surface)
+        return;
+
+    mir_window_set_event_handler(xmir_window->surface, NULL, NULL);
+
+    if (xmir_screen->flatten && xmir_screen->flatten_top == xmir_window) {
+        xmir_screen->flatten_top = NULL;
+        if (!xorg_list_is_empty(&xmir_screen->flattened_list)) {
+            xmir_screen->flatten_top =
+                xorg_list_first_entry(&xmir_screen->flattened_list,
+                                      struct xmir_window,
+                                      link_flattened);
+            xorg_list_del(&xmir_screen->flatten_top->link_flattened);
+            xmir_bequeath_surface(xmir_window, xmir_screen->flatten_top);
+        }
+    }
+
+    if (xmir_window->surface) {
+        if (xmir_screen->neverclose) {
+            xmir_screen->neverclosed = xmir_window->surface;
+            xmir_clear_to_black(xmir_screen->neverclosed);
+        }
+        else {
+            mir_window_release_sync(xmir_window->surface);
+        }
+
+        xmir_window->surface = NULL;
+    }
+
+    xmir_process_from_eventloop_except(xmir_window);
+
+    RegionUninit(&xmir_window->region);
+}
+
+static Bool
+xmir_unrealize_window(WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    Bool ret;
+
+    if (window == xmir_screen->last_focus)
+        xmir_screen->last_focus = NULL;
+
+    xmir_unmap_input(xmir_screen, window);
+
+    screen->UnrealizeWindow = xmir_screen->UnrealizeWindow;
+    ret = (*screen->UnrealizeWindow) (window);
+    xmir_screen->UnrealizeWindow = screen->UnrealizeWindow;
+    screen->UnrealizeWindow = xmir_unrealize_window;
+
+    xmir_unmap_surface(xmir_screen, window, FALSE);
+
+    return ret;
+}
+
+static Bool
+xmir_destroy_window(WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    Bool ret;
+
+    if (!window->parent)
+        xmir_screen->destroying_root = TRUE;
+
+    xmir_unmap_input(xmir_screen, window);
+    xmir_unmap_surface(xmir_screen, window, TRUE);
+
+    screen->DestroyWindow = xmir_screen->DestroyWindow;
+    ret = (*screen->DestroyWindow) (window);
+    xmir_screen->DestroyWindow = screen->DestroyWindow;
+    screen->DestroyWindow = xmir_destroy_window;
+
+    return ret;
+}
+
+static void
+xmir_resize_window(WindowPtr window, int x, int y,
+                   unsigned int w, unsigned int h, WindowPtr sib)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    struct xmir_window *xmir_window = xmir_window_get(window);
+
+    screen->ResizeWindow = xmir_screen->ResizeWindow;
+    (*screen->ResizeWindow) (window, x, y, w, h, sib);
+    xmir_screen->ResizeWindow = screen->ResizeWindow;
+    screen->ResizeWindow = xmir_resize_window;
+
+    if (xmir_window->surface) {
+        /* This is correct in theory but most Mir shells don't do it yet */
+        MirWindowSpec *changes =
+            mir_create_window_spec(xmir_screen->conn);
+        mir_window_spec_set_width(changes, w);
+        mir_window_spec_set_height(changes, h);
+        mir_window_apply_spec(xmir_window->surface, changes);
+        mir_window_spec_release(changes);
+
+        XMIR_DEBUG(("X window %p resized to %ux%u %+d%+d with sibling %p\n",
+                    window, w, h, x, y, sib));
+    }
+
+    xmir_window_update_region(xmir_window);
+}
+
+static Bool
+xmir_close_screen(ScreenPtr screen)
+{
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    struct xmir_output *xmir_output, *next_xmir_output;
+    Bool ret;
+
+    xmir_screen->closing = TRUE;
+
+    if (xmir_screen->glamor && xmir_screen->gbm)
+        DRI2CloseScreen(screen);
+
+    screen->CloseScreen = xmir_screen->CloseScreen;
+    ret = screen->CloseScreen(screen);
+
+    xorg_list_for_each_entry_safe(xmir_output, next_xmir_output,
+                                  &xmir_screen->output_list, link)
+        xmir_output_destroy(xmir_output);
+
+    if (xmir_screen->glamor)
+        xmir_glamor_fini(xmir_screen);
+    mir_display_config_release(xmir_screen->display);
+    mir_connection_release(xmir_screen->conn);
+
+    xmir_fini_thread_to_eventloop();
+    free(xmir_screen->driver_name);
+    free(xmir_screen);
+
+    return ret;
+}
+
+static Bool
+xmir_is_unblank(int mode)
+{
+    switch (mode) {
+    case SCREEN_SAVER_OFF:
+    case SCREEN_SAVER_FORCER:
+        return TRUE;
+    case SCREEN_SAVER_ON:
+    case SCREEN_SAVER_CYCLE:
+        return FALSE;
+    default:
+        ErrorF("Unexpected save screen mode: %d\n", mode);
+        return TRUE;
+    }
+}
+
+Bool
+DPMSSupported(void)
+{
+    struct xmir_screen *xmir_screen = xmir_screen_get(screenInfo.screens[0]);
+    return !xmir_screen->rootless && !xmir_screen->windowed;
+}
+
+int
+DPMSSet(ClientPtr client, int level)
+{
+    int rc = Success;
+    struct xmir_screen *xmir_screen = xmir_screen_get(screenInfo.screens[0]);
+
+    DPMSPowerLevel = level;
+
+    if (level != DPMSModeOn) {
+        if (xmir_is_unblank(screenIsSaved))
+            rc = dixSaveScreens(client, SCREEN_SAVER_FORCER, ScreenSaverActive);
+    }
+    else {
+        if (!xmir_is_unblank(screenIsSaved))
+            rc = dixSaveScreens(client, SCREEN_SAVER_OFF, ScreenSaverReset);
+    }
+
+    if (rc != Success)
+        return rc;
+
+    xmir_output_dpms(xmir_screen, level);
+
+    return Success;
+}
+
+static Bool
+xmir_save_screen(ScreenPtr screen, int mode)
+{
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+
+    if (xmir_is_unblank(mode))
+        return xmir_output_dpms(xmir_screen, DPMSModeOn);
+    else
+        return xmir_output_dpms(xmir_screen, DPMSModeOff);
+}
+
+static void
+xmir_block_handler(ScreenPtr screen, void *ptv)
+{
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    struct xmir_window *xmir_window, *next;
+
+    xorg_list_for_each_entry_safe(xmir_window, next,
+                                  &xmir_screen->damage_window_list,
+                                  link_damage) {
+        if (xmir_window->has_free_buffer) {
+            xmir_repaint(xmir_window);
+        }
+    }
+}
+
+static Bool
+xmir_create_screen_resources(ScreenPtr screen)
+{
+    struct xmir_screen *xmir_screen = xmir_screen_get(screen);
+    int ret;
+
+    screen->CreateScreenResources = xmir_screen->CreateScreenResources;
+    ret = (*screen->CreateScreenResources) (screen);
+    xmir_screen->CreateScreenResources = screen->CreateScreenResources;
+    screen->CreateScreenResources = xmir_create_screen_resources;
+
+    if (!ret)
+        return ret;
+
+    if (!xmir_screen->rootless)
+        screen->devPrivate = screen->CreatePixmap(screen,
+                                                  screen->width,
+                                                  screen->height,
+                                                  screen->rootDepth,
+                                                  CREATE_PIXMAP_USAGE_BACKING_PIXMAP);
+    else
+        screen->devPrivate = fbCreatePixmap(screen, 0, 0, screen->rootDepth, 0);
+
+    if (!screen->devPrivate)
+        return FALSE;
+
+#ifdef GLAMOR_HAS_GBM
+    if (xmir_screen->glamor && !xmir_screen->rootless) {
+        glamor_pixmap_private *pixmap_priv = glamor_get_pixmap_private(screen->devPrivate);
+
+        glBindFramebuffer(GL_FRAMEBUFFER, pixmap_priv->fbo->fb);
+        glClear(GL_COLOR_BUFFER_BIT);
+        glBindFramebuffer(GL_FRAMEBUFFER, 0);
+
+        glamor_set_screen_pixmap(screen->devPrivate, NULL);
+    }
+#endif
+
+    return TRUE;
+}
+
+struct xmir_visit_set_pixmap_window {
+    PixmapPtr old, new;
+};
+
+static int
+xmir_visit_set_window_pixmap(WindowPtr window, void *data)
+{
+    struct xmir_visit_set_pixmap_window *visit = data;
+
+    if (fbGetWindowPixmap(window) == visit->old) {
+        window->drawable.pScreen->SetWindowPixmap(window, visit->new);
+        return WT_WALKCHILDREN;
+    }
+
+    return WT_DONTWALKCHILDREN;
+}
+
+static void
+xmir_set_screen_pixmap(PixmapPtr pixmap)
+{
+    ScreenPtr screen = pixmap->drawable.pScreen;
+    PixmapPtr old_front = screen->devPrivate;
+    WindowPtr root;
+
+    root = screen->root;
+    if (root) {
+        struct xmir_visit_set_pixmap_window visit = { old_front, pixmap };
+        assert(fbGetWindowPixmap(root) == old_front);
+        TraverseTree(root, xmir_visit_set_window_pixmap, &visit);
+        assert(fbGetWindowPixmap(root) == pixmap);
+    }
+
+    screen->devPrivate = pixmap;
+
+    if (old_front)
+        screen->DestroyPixmap(old_front);
+}
+
+void
+xmir_disable_screensaver(struct xmir_screen *xmir_screen)
+{
+    ScreenSaverTime = 0;
+}
+
+static Bool
+xmir_screen_init(ScreenPtr pScreen, int argc, char **argv)
+{
+    struct xmir_screen *xmir_screen;
+    MirConnection *conn;
+    Pixel red_mask, blue_mask, green_mask;
+    int ret, bpc, i;
+    int client_fd = -1;
+    char *socket = NULL;
+    const char *appid = "XMIR";
+    unsigned int formats, f;
+    MirPixelFormat format[1024];
+
+    if (!dixRegisterPrivateKey(&xmir_screen_private_key, PRIVATE_SCREEN, 0) ||
+        !dixRegisterPrivateKey(&xmir_window_private_key, PRIVATE_WINDOW, 0) ||
+        !dixRegisterPrivateKey(&xmir_pixmap_private_key, PRIVATE_PIXMAP, 0))
+        return FALSE;
+
+    memset(&known_atom, 0, sizeof known_atom);
+
+    xmir_screen = calloc(sizeof *xmir_screen, 1);
+    if (!xmir_screen)
+        return FALSE;
+
+    xmir_screen->conn = NULL;
+
+    xmir_init_thread_to_eventloop();
+    dixSetPrivate(&pScreen->devPrivates, &xmir_screen_private_key, xmir_screen);
+    xmir_screen->screen = pScreen;
+    xmir_screen->glamor = glamor_dri;
+
+    for (i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-rootless") == 0) {
+            xmir_screen->rootless = 1;
+            xmir_disable_screensaver(xmir_screen);
+        }
+        else if (strcmp(argv[i], "-flatten") == 0) {
+            xmir_screen->flatten = TRUE;
+        }
+        else if (strcmp(argv[i], "-neverclose") == 0) {
+            xmir_screen->neverclose = TRUE;
+        }
+        else if (strcmp(argv[i], "-title") == 0) {
+            xmir_screen->title = argv[++i];
+        }
+        else if (strcmp(argv[i], "-mir") == 0) {
+            appid = argv[++i];
+        }
+        else if (strcmp(argv[i], "-mirSocket") == 0) {
+            socket = argv[++i];
+        }
+        else if (strcmp(argv[i], "-sw") == 0) {
+            xmir_screen->glamor = glamor_off;
+        }
+        else if (strcmp(argv[i], "-egl") == 0) {
+            if (xmir_screen->glamor != glamor_egl_sync)
+                xmir_screen->glamor = glamor_egl;
+        }
+        else if (strcmp(argv[i], "-2x") == 0) {
+            xmir_screen->doubled = 1;
+        }
+        else if (strcmp(argv[i], "-debug") == 0) {
+            xmir_debug_logging = TRUE;
+        }
+        else if (strcmp(argv[i], "-damage") == 0) {
+            /* Ignored. Damage-all is now the default and only option. */
+        }
+        else if (strcmp(argv[i], "-egl_sync") == 0) {
+            xmir_screen->glamor = glamor_egl_sync;
+        }
+        else if (strcmp(argv[i], "-fd") == 0) {
+            client_fd = (int)strtol(argv[++i], (char **)NULL, 0);
+        }
+    }
+
+    if (xmir_screen->flatten && !xmir_screen->rootless) {
+        FatalError("-flatten is not valid without -rootless\n");
+        return FALSE;
+    }
+    if (xmir_screen->neverclose && !xmir_screen->flatten) {
+        FatalError("-neverclose is not valid without -rootless -flatten\n");
+        return FALSE;
+    }
+
+    if (!xmir_screen->title)
+        xmir_screen->title = xmir_screen->rootless ? get_title_from_top_window
+                                                   : "Xmir root window";
+
+#if defined(__arm__) || defined(__aarch64__)
+    if (xmir_screen->glamor == glamor_dri) {
+        XMIR_DEBUG(("ARM architecture: Defaulting to software mode because "
+                    "glamor is not stable\n"));
+        /* Hide the ARM glamor bugs for now so we can have working phones */
+        xmir_screen->glamor = glamor_off;
+    }
+#endif
+
+    if (client_fd != -1) {
+        if (!AddClientOnOpenFD(client_fd)) {
+            FatalError("failed to connect to client fd %d\n", client_fd);
+            return FALSE;
+        }
+    }
+
+    conn = mir_connect_sync(socket, appid);
+    if (!mir_connection_is_valid(conn)) {
+        FatalError("Failed to connect to Mir: %s\n",
+                   mir_connection_get_error_message(conn));
+        return FALSE;
+    }
+    xmir_screen->conn = conn;
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+    mir_connection_get_platform(xmir_screen->conn, &xmir_screen->platform);
+#pragma GCC diagnostic pop
+
+    xorg_list_init(&xmir_screen->output_list);
+    xorg_list_init(&xmir_screen->input_list);
+    xorg_list_init(&xmir_screen->damage_window_list);
+    xorg_list_init(&xmir_screen->flattened_list);
+    xmir_screen->depth = 24;
+
+    mir_connection_get_available_surface_formats(xmir_screen->conn,
+        format, sizeof(format)/sizeof(format[0]), &formats);
+
+#if 0  /* Emulate the Mir Android graphics platform for LP: #1573470 */
+    format[0] = mir_pixel_format_abgr_8888;
+    format[1] = mir_pixel_format_xbgr_8888;
+    formats = 2;
+#endif
+
+    for (f = 0; f < formats; ++f) {
+        switch (format[f]) {
+        case mir_pixel_format_argb_8888:
+        case mir_pixel_format_abgr_8888:
+            xmir_screen->depth32_pixel_format = format[f];
+            break;
+        case mir_pixel_format_xrgb_8888:
+        case mir_pixel_format_xbgr_8888:
+        case mir_pixel_format_bgr_888:
+            xmir_screen->depth24_pixel_format = format[f];
+            break;
+        default:
+            /* Other/new pixel formats don't need mentioning. We only
+               care about Xorg-compatible formats */
+            break;
+        }
+    }
+
+    xmir_screen->display = mir_connection_create_display_configuration(conn);
+    if (xmir_screen->display == NULL) {
+        FatalError("could not create display config\n");
+        return FALSE;
+    }
+
+    /*
+     * Core DPI cannot report correct values (it's one value and we might have
+     * multiple displays). Use the value from the -dpi command line if set, or
+     * 96 otherwise.
+     *
+     * This matches the behaviour of all the desktop Xorg drivers. Clients
+     * which care can use the XRandR extension to get correct per-output DPI
+     * information.
+     */
+    xmir_screen->dpi = monitorResolution > 0 ? monitorResolution : 96;
+
+    if (!xmir_screen_init_output(xmir_screen))
+        return FALSE;
+
+    if (xmir_screen->glamor)
+        xmir_screen_init_glamor(xmir_screen);
+
+    bpc = 8;
+    green_mask = 0x00ff00;
+    switch (xmir_screen->depth24_pixel_format)
+    {
+    case mir_pixel_format_xrgb_8888:
+    case mir_pixel_format_bgr_888:  /* Little endian: Note the reversal */
+        red_mask = 0xff0000;
+        blue_mask = 0x0000ff;
+        break;
+    case mir_pixel_format_xbgr_8888:
+        red_mask = 0x0000ff;
+        blue_mask = 0xff0000;
+        break;
+    default:
+        ErrorF("No Mir-compatible TrueColor formats\n");
+        return FALSE;
+    }
+
+    miSetVisualTypesAndMasks(xmir_screen->depth,
+                             ((1 << TrueColor) | (1 << DirectColor)),
+                             bpc, TrueColor,
+                             red_mask, green_mask, blue_mask);
+
+    miSetPixmapDepths();
+
+    ret = fbScreenInit(pScreen, NULL,
+                       pScreen->width, pScreen->height,
+                       xmir_screen->dpi, xmir_screen->dpi, 0,
+                       BitsPerPixel(xmir_screen->depth));
+    if (!ret)
+        return FALSE;
+
+    fbPictureInit(pScreen, 0, 0);
+
+    pScreen->blackPixel = 0;
+    pScreen->whitePixel = 1;
+
+    ret = fbCreateDefColormap(pScreen);
+
+    if (!xmir_screen_init_cursor(xmir_screen))
+        return FALSE;
+
+    pScreen->SaveScreen = xmir_save_screen;
+    pScreen->BlockHandler = xmir_block_handler;
+    pScreen->SetScreenPixmap = xmir_set_screen_pixmap;
+
+    xmir_screen->CreateScreenResources = pScreen->CreateScreenResources;
+    pScreen->CreateScreenResources = xmir_create_screen_resources;
+
+#ifdef GLAMOR_HAS_GBM
+    if (xmir_screen->glamor && !xmir_glamor_init(xmir_screen)) {
+        if (xmir_screen->glamor >= glamor_egl)
+            FatalError("EGL requested, but not available\n");
+        xmir_screen->glamor = glamor_off;
+    }
+
+    if (xmir_screen->glamor && xmir_screen->gbm && !xmir_dri2_screen_init(xmir_screen))
+        ErrorF("Failed to initialize DRI2.\n");
+#endif
+
+    if (!xmir_screen->glamor && xmir_screen->doubled)
+        FatalError("-2x requires EGL support\n");
+
+    xmir_screen->CreateWindow = pScreen->CreateWindow;
+    pScreen->CreateWindow = xmir_create_window;
+
+    xmir_screen->RealizeWindow = pScreen->RealizeWindow;
+    pScreen->RealizeWindow = xmir_realize_window;
+
+    xmir_screen->DestroyWindow = pScreen->DestroyWindow;
+    pScreen->DestroyWindow = xmir_destroy_window;
+
+    xmir_screen->ResizeWindow = pScreen->ResizeWindow;
+    pScreen->ResizeWindow = xmir_resize_window;
+
+    xmir_screen->UnrealizeWindow = pScreen->UnrealizeWindow;
+    pScreen->UnrealizeWindow = xmir_unrealize_window;
+
+    xmir_screen->CloseScreen = pScreen->CloseScreen;
+    pScreen->CloseScreen = xmir_close_screen;
+
+    {
+        int v;
+        XMIR_DEBUG(("XMir initialized with %hd visuals:\n",
+                    pScreen->numVisuals));
+        for (v = 0; v < pScreen->numVisuals; ++v) {
+            VisualPtr visual = pScreen->visuals + v;
+            XMIR_DEBUG(("\tVisual id 0x%x: %lx %lx %lx, %hd planes\n",
+                        (int)visual->vid,
+                        (long)visual->redMask,
+                        (long)visual->greenMask,
+                        (long)visual->blueMask,
+                        visual->nplanes));
+        }
+    }
+
+    return ret;
+}
+
+static const ExtensionModule xmir_extensions[] = {
+#ifdef DRI2
+    { DRI2ExtensionInit, "DRI2", &noDRI2Extension },
+#endif
+#ifdef GLXEXT
+    { GlxExtensionInit, "GLX", &noGlxExtension },
+#endif
+};
+
+void
+InitOutput(ScreenInfo *screen_info, int argc, char **argv)
+{
+    int depths[] = { 1, 4, 8, 15, 16, 24, 32 };
+    int bpp[] =    { 1, 8, 8, 16, 16, 32, 32 };
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(depths); i++) {
+        screen_info->formats[i].depth = depths[i];
+        screen_info->formats[i].bitsPerPixel = bpp[i];
+        screen_info->formats[i].scanlinePad = BITMAP_SCANLINE_PAD;
+    }
+
+    screen_info->imageByteOrder = IMAGE_BYTE_ORDER;
+    screen_info->bitmapScanlineUnit = BITMAP_SCANLINE_UNIT;
+    screen_info->bitmapScanlinePad = BITMAP_SCANLINE_PAD;
+    screen_info->bitmapBitOrder = BITMAP_BIT_ORDER;
+    screen_info->numPixmapFormats = ARRAY_SIZE(depths);
+
+    if (serverGeneration == 1) {
+#ifdef GLXEXT
+        GlxPushProvider(&__glXDRI2Provider);
+#endif
+        LoadExtensionList(xmir_extensions,
+                          ARRAY_SIZE(xmir_extensions), TRUE);
+    }
+
+    if (AddScreen(xmir_screen_init, argc, argv) == -1) {
+        FatalError("Couldn't add screen\n");
+    }
+}
--- /dev/null
+++ b/hw/xmir/xmir.h
@@ -0,0 +1,234 @@
+/*
+ * Copyright © 2015-2017 Canonical Ltd
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XMIR_H
+#define XMIR_H
+
+#include <dix-config.h>
+#include <xorg-server.h>
+
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <mir_toolkit/mir_client_library.h>
+
+#include <X11/X.h>
+
+#include <fb.h>
+#include <input.h>
+#include <dix.h>
+#include <randrstr.h>
+#include <exevents.h>
+#include <dri2.h>
+
+#define MESA_EGL_NO_X11_HEADERS
+#include <epoxy/egl.h>
+#include <epoxy/gl.h>
+
+struct xmir_window;
+struct xmir_output;
+
+struct xmir_screen {
+    ScreenPtr screen;
+
+    int depth, rootless, doubled;
+    enum {glamor_off=0, glamor_dri, glamor_egl, glamor_egl_sync} glamor;
+
+    CreateScreenResourcesProcPtr CreateScreenResources;
+    CloseScreenProcPtr CloseScreen;
+    CreateWindowProcPtr CreateWindow;
+    DestroyWindowProcPtr DestroyWindow;
+    RealizeWindowProcPtr RealizeWindow;
+    UnrealizeWindowProcPtr UnrealizeWindow;
+    ResizeWindowProcPtr ResizeWindow;
+
+    struct xorg_list output_list;
+    struct xorg_list input_list;
+    struct xorg_list damage_window_list;
+
+    MirConnection *conn;
+    MirDisplayConfig *display;
+    MirPlatformPackage platform;
+
+    /* Bookkeeping for eglSwapBuffers */
+    pthread_mutex_t mutex;
+    pthread_cond_t cond;
+    pthread_t thread;
+    int alive;
+    struct xorg_list swap_list;
+    void *swap_surface;
+
+    char *device_name, *driver_name;
+    int drm_fd;
+    void *egl_display, *egl_context, *swap_context;
+    struct gbm_device *gbm;
+    struct glamor_context *glamor_ctx;
+    void *egl_surface;
+
+    MirPixelFormat depth24_pixel_format, depth32_pixel_format;
+    Bool flatten;
+    Bool neverclose;
+    Bool destroying_root;
+    Bool closing;
+    const char *title;
+    MirWindow *neverclosed;
+    struct xorg_list flattened_list;
+    struct xmir_window *flatten_top;
+    WindowPtr last_focus;
+    Window saved_focus;
+
+    int dpi;
+
+    DRI2InfoRec dri2;
+
+    struct xmir_output *windowed;
+    Bool glamor_has_GL_EXT_framebuffer_blit;
+};
+
+struct xmir_pixmap {
+    unsigned int fake_back;
+    struct gbm_bo *bo;
+    void *image;
+};
+
+struct xmir_window {
+    struct xmir_screen *xmir_screen;
+    MirWindow *surface;
+    WindowPtr window;
+    DamagePtr damage;
+    RegionRec region;
+
+    int surface_width, surface_height;
+    int buf_width, buf_height;
+
+    struct xorg_list link_damage;
+    int orientation;
+    unsigned int has_free_buffer:1;
+
+    struct xorg_list link_flattened;
+
+    void *egl_surface, *image;
+    PixmapPtr back_pixmap, front_pixmap, reuse_pixmap;
+
+    struct xmir_flip {
+        ClientPtr client;
+        int type;
+        DrawablePtr draw;
+        DRI2SwapEventPtr func;
+        void *data;
+        struct xorg_list entry;
+    } flip;
+
+    char wm_name[256];
+};
+
+struct xmir_input {
+    DeviceIntPtr pointer;
+    DeviceIntPtr keyboard;
+    DeviceIntPtr touch;
+    struct xmir_screen *xmir_screen;
+    struct xmir_window *focus_window;
+    uint32_t id;
+    int touch_id;
+    struct xorg_list link;
+};
+
+struct xmir_output {
+    struct xorg_list link;
+    struct xmir_screen *xmir_screen;
+    RROutputPtr randr_output;
+    RRCrtcPtr randr_crtc;
+    int32_t x, y, width, height;
+};
+
+extern Bool xmir_debug_logging;
+#define XMIR_DEBUG(_args)  {if (xmir_debug_logging) ErrorF _args;}
+
+struct xmir_window *xmir_window_get(WindowPtr window);
+struct xmir_screen *xmir_screen_get(ScreenPtr screen);
+struct xmir_pixmap *xmir_pixmap_get(PixmapPtr pixmap);
+void xmir_pixmap_set(PixmapPtr pixmap, struct xmir_pixmap *xmir_pixmap);
+
+void xmir_handle_surface_event(struct xmir_window *, MirWindowAttrib, int);
+void xmir_handle_buffer_available(struct xmir_screen *xmir_screen,
+                                  struct xmir_window *xmir_win,
+                                  void *unused);
+void xmir_close_surface(struct xmir_window *);
+
+void xmir_repaint(struct xmir_window *);
+
+void xmir_disable_screensaver(struct xmir_screen *xmir_screen);
+
+/* xmir-input.c */
+Bool xmir_screen_init_cursor(struct xmir_screen *xmir_screen);
+
+/* xmir-output.c */
+Bool xmir_screen_init_output(struct xmir_screen *xmir_screen);
+void xmir_output_destroy(struct xmir_output *xmir_output);
+Bool xmir_output_dpms(struct xmir_screen *xmir_screen, int dpms);
+void xmir_output_handle_resize(struct xmir_window *, int, int);
+void xmir_output_handle_orientation(struct xmir_window *, MirOrientation);
+
+/* xmir-cvt.c */
+RRModePtr xmir_cvt(int HDisplay, int VDisplay, float VRefresh, Bool Reduced, Bool Interlaced);
+
+/* xmir-dri2.c */
+Bool xmir_dri2_screen_init(struct xmir_screen *xmir_screen);
+
+/* xmir-glamor.c */
+Bool xmir_glamor_init(struct xmir_screen *xmir_screen);
+Bool xmir_screen_init_glamor(struct xmir_screen *xmir_screen);
+void xmir_glamor_fini(struct xmir_screen *xmir_screen);
+
+PixmapPtr xmir_glamor_win_get_back(struct xmir_screen *, struct xmir_window *, DrawablePtr);
+void xmir_glamor_copy(struct xmir_screen *, struct xmir_window *, RegionPtr);
+void xmir_glamor_realize_window(struct xmir_screen *, struct xmir_window *, WindowPtr);
+void xmir_glamor_unrealize_window(struct xmir_screen *, struct xmir_window *, WindowPtr);
+
+struct glamor_pixmap_private;
+void xmir_glamor_copy_egl_common(DrawablePtr, PixmapPtr src, struct glamor_pixmap_private *,
+                                 BoxPtr, int width, int height, int dx, int dy, int orientation);
+
+/* xmir-thread-proxy.c */
+void xmir_init_thread_to_eventloop(void);
+void xmir_fini_thread_to_eventloop(void);
+
+typedef void (xmir_event_callback)(struct xmir_screen*, struct xmir_window*,
+                                   void *arg);
+void xmir_post_to_eventloop(xmir_event_callback *cb,
+                            struct xmir_screen*, struct xmir_window*, void*);
+void xmir_process_from_eventloop(void);
+void xmir_process_from_eventloop_except(const struct xmir_window*);
+
+/* xmir-input.c */
+void xmir_surface_handle_event(MirWindow *surface, MirEvent const* ev, void *context);
+
+#define XMIR_CREATE_PIXMAP_USAGE_FLIP 0x10000000
+
+#define XORG_VERSION_NUMERIC(major,minor,patch,snap,dummy) \
+	(((major) * 10000000) + ((minor) * 100000) + ((patch) * 1000) + snap)
+
+#endif
